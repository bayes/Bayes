/*
 * BayesDiffTensor.java
 *
 * Created on January 28, 2008, 1:17 PM
 */
package applications.bayesDiffTensor;

import run.JRun;
import bayes.PackageManager;
import bayes.DirectoryManager;
import javax.swing.*;
import applications.model.AsciiModel;
import ascii.AsciiIO;
import java.io.*;
import bayes.JobDirections;
import bayes.WriteBayesParams;
import interfacebeans.*;
import static load.LoadAndViewData.*;
import bayes.ParameterPrior;
import utilities.DisplayText;
import bayes.Enums.*;
import bayes.BayesManager;
import fid.Procpar;
import java.awt.Component;
import java.awt.event.ItemEvent;
import java.util.List;
import utilities.IO;
import bayes.ParameterPrior.ORDER_TYPE;
import bayes.ParameterPrior.PRIOR_TYPE;
import bayes.ParameterPrior.PARAMETER_TYPE;
import bayes.Reset;
import java.util.ArrayList;


public class BayesDiffTensor extends javax.swing.JPanel
        implements AsciiModel, java.beans.PropertyChangeListener , bayes.ApplicationConstants{

    private ParameterPrior Lambda1Prior = null; //0
    private ParameterPrior Lambda2Prior = null; //1
    private ParameterPrior Lambda3Prior = null; //2
    private ParameterPrior ThetaPrior = null; //3
    private ParameterPrior PhiPrior = null; //4
    private ParameterPrior PsiPrior = null; //5
    private ParameterPrior gammaPrior = null; //6
    private ParameterPrior SmallDeltaPrior = null; //7
    private ParameterPrior LargeDeltaPrior = null; //8
    private ParameterPrior gdiffPrior = null; //9
    private ParameterPrior AmpTensorPrior = null; //10
    private ParameterPrior ConstantPrior = null; //11
    public static final int GYRIMAGNETIC_RATIO_WATER = 26752;
    public List<ParameterPrior> priors      = new ArrayList <ParameterPrior>();



  

   
 

    public enum ABSCISSA_TYPE {

        G_VECTOR("Use g Vectors", 3),
        B_VECTOR("Use b Vectors", 3),
        B_MATRIX("Use b Matrix", 6);
        private String string = "";
        private int abscissaNumber = 3;

        ABSCISSA_TYPE(String str, int abN) {
            setString(str);
            setAbscissaNumber(abN);

        }

        @Override
        public String toString() {
            return string;
        }

        public String getString() {
            return string;
        }

        public void setString(String string) {
            this.string = string;
        }

        public int getAbscissaNumber() {
            return abscissaNumber;
        }

        public void setAbscissaNumber(int abscissaNumber) {
            this.abscissaNumber = abscissaNumber;
        }
    };
    private ABSCISSA_TYPE abscissaType          =   ABSCISSA_TYPE.G_VECTOR;
    public boolean constantIsSelected           =   false;
    private boolean includeOutliers             =   false;
    public String numberOfTensors               =   "1";
    private boolean isLoaded                     =   false;



    /** Creates new form BayesDiffTensor */
    public BayesDiffTensor() {
        PackageManager.setCurrentApplication(this);
        boolean isDeseralized = bayes.Serialize.deserializeCurrenExperiment();
        initComponents();
      

        BayesManager.pcs.addPropertyChangeListener(this);


        if (isDeseralized) {
            JRun.fireJobIDChange();
        } else {
            initializePriors();
            AllViewers.showInstructions();
        }

        switch (getAbscissaType()) {
            case G_VECTOR:  getgVectorCB().setSelected(true); break;
            case B_VECTOR:  getbVectorCB().setSelected(true); break;
            case B_MATRIX:  getbMatrixCB().setSelected(true); break;

        }

        isLoaded   = true;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        abscissaOptionbuttonGroup = new javax.swing.ButtonGroup();
        jSplitPane1 = new javax.swing.JSplitPane();
        setup_panel = new javax.swing.JPanel();
        analysOptionPane = new javax.swing.JPanel();
        includeOutliersLabel = new javax.swing.JLabel();
        includeOutliersCheckBox = new javax.swing.JCheckBox();
        jLabel7 = new javax.swing.JLabel();
        jLabel11 = new javax.swing.JLabel();
        jRun = new run.JRun();
        jserver = interfacebeans.JServer.getInstance();
        abscOptionPane = new javax.swing.JPanel();
        tensorNumberLabel = new javax.swing.JLabel();
        jTensorComboBox = new javax.swing.JComboBox();
        jConstCheckBox = new javax.swing.JCheckBox();
        includeConstantLabel = new javax.swing.JLabel();
        Options1 = new javax.swing.JPanel();
        labelForGVector = new javax.swing.JLabel();
        gVectorCB = new javax.swing.JCheckBox();
        LabelForBMatrix = new javax.swing.JLabel();
        bMatrixCB = new javax.swing.JCheckBox();
        labelForBVector = new javax.swing.JLabel();
        bVectorCB = new javax.swing.JCheckBox();
        jResetSave = new interfacebeans.JResetSave();
        graph_panel = AllViewers.getInstance ();

        FormListener formListener = new FormListener();

        setName("Form"); // NOI18N
        setLayout(new java.awt.BorderLayout());

        jSplitPane1.setOrientation(javax.swing.JSplitPane.VERTICAL_SPLIT);
        jSplitPane1.setName("jSplitPane1"); // NOI18N
        jSplitPane1.setOneTouchExpandable(true);

        setup_panel.setName("setup_panel"); // NOI18N

        analysOptionPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Analysis Options"));
        analysOptionPane.setName("analysOptionPane"); // NOI18N
        analysOptionPane.setLayout(new java.awt.GridBagLayout());

        includeOutliersLabel.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        includeOutliersLabel.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        includeOutliersLabel.setText("Find Outliers "); // NOI18N
        includeOutliersLabel.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        includeOutliersLabel.setName("includeOutliersLabel"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.weighty = 1.0;
        analysOptionPane.add(includeOutliersLabel, gridBagConstraints);

        includeOutliersCheckBox.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        includeOutliersCheckBox.setSelected(isIncludeOutliers () );
        includeOutliersCheckBox.setToolTipText("<html> <font color=\"red\" size = \"+1\"><bold> Enable outlier detection.</font></bold><br>  \n(i.e., look for residual<br>\nvalues that are larger than 3 standard deviations <br>\n and remove these outliers from the analysis.)</html>\n"); // NOI18N
        includeOutliersCheckBox.setContentAreaFilled(false);
        includeOutliersCheckBox.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        includeOutliersCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        includeOutliersCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rb.gif"))); // NOI18N
        includeOutliersCheckBox.setIconTextGap(16);
        includeOutliersCheckBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
        includeOutliersCheckBox.setName("includeOutliersCheckBox"); // NOI18N
        includeOutliersCheckBox.setRolloverEnabled(true);
        includeOutliersCheckBox.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbr.gif"))); // NOI18N
        includeOutliersCheckBox.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbrs.gif"))); // NOI18N
        includeOutliersCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbs.gif"))); // NOI18N
        includeOutliersCheckBox.addItemListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 2.0;
        analysOptionPane.add(includeOutliersCheckBox, gridBagConstraints);

        jLabel7.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jLabel7.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        jLabel7.setName("jLabel7"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.weighty = 2.0;
        analysOptionPane.add(jLabel7, gridBagConstraints);

        jLabel11.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jLabel11.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        jLabel11.setName("jLabel11"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.weighty = 2.0;
        analysOptionPane.add(jLabel11, gridBagConstraints);

        jRun.setName("jRun"); // NOI18N

        jserver.setName("jserver"); // NOI18N

        abscOptionPane.setBorder(javax.swing.BorderFactory.createTitledBorder("Model Settings"));
        abscOptionPane.setName("abscOptionPane"); // NOI18N
        abscOptionPane.setLayout(new java.awt.GridBagLayout());

        tensorNumberLabel.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        tensorNumberLabel.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        tensorNumberLabel.setText("Tensor Number"); // NOI18N
        tensorNumberLabel.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        tensorNumberLabel.setName("tensorNumberLabel"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 2.0;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
        abscOptionPane.add(tensorNumberLabel, gridBagConstraints);

        jTensorComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "1", "2", "3"}));
        jTensorComboBox.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nSet number of tensors in the model.\n</font></p><html>\n\n\n\n\n"); // NOI18N
        jTensorComboBox.setName("jTensorComboBox"); // NOI18N
        jTensorComboBox.addActionListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
        abscOptionPane.add(jTensorComboBox, gridBagConstraints);

        jConstCheckBox.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nInclude constant in the model.\n</font></p><html>\n\n\n"); // NOI18N
        jConstCheckBox.setFocusPainted(false);
        jConstCheckBox.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jConstCheckBox.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        jConstCheckBox.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rb.gif"))); // NOI18N
        jConstCheckBox.setName("jConstCheckBox"); // NOI18N
        jConstCheckBox.setPressedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbp.gif"))); // NOI18N
        jConstCheckBox.setRolloverEnabled(true);
        jConstCheckBox.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbr.gif"))); // NOI18N
        jConstCheckBox.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbrs.gif"))); // NOI18N
        jConstCheckBox.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbs.gif"))); // NOI18N
        jConstCheckBox.addActionListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.ipady = 10;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
        abscOptionPane.add(jConstCheckBox, gridBagConstraints);

        includeConstantLabel.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        includeConstantLabel.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        includeConstantLabel.setText("Include Constant"); // NOI18N
        includeConstantLabel.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        includeConstantLabel.setName("includeConstantLabel"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 2.0;
        gridBagConstraints.insets = new java.awt.Insets(2, 2, 2, 2);
        abscOptionPane.add(includeConstantLabel, gridBagConstraints);

        Options1.setBorder(javax.swing.BorderFactory.createTitledBorder("Abscissa Options"));
        Options1.setName("Options1"); // NOI18N
        Options1.setLayout(new java.awt.GridBagLayout());

        labelForGVector.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        labelForGVector.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelForGVector.setText("Use g Vectors"); // NOI18N
        labelForGVector.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        labelForGVector.setName("labelForGVector"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.weighty = 1.0;
        Options1.add(labelForGVector, gridBagConstraints);

        abscissaOptionbuttonGroup.add(gVectorCB);
        gVectorCB.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        gVectorCB.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\n\n\"Use g Vectors\" automatically sets \"3\" abscissa and disables<br>\n\"gamma\", \"gdiff\", \"tdelta\" and \"tDELta\". Note that no unit <br>\nconversion is done. After checking this box, 5 column ascii <br>\ndata can be loaded.  Image pixel data can also be loaded <br>\nprovided three parameters are arraied.\n\n\n</font></p><html>\n\n"); // NOI18N
        gVectorCB.setContentAreaFilled(false);
        gVectorCB.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        gVectorCB.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        gVectorCB.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rb.gif"))); // NOI18N
        gVectorCB.setIconTextGap(16);
        gVectorCB.setMargin(new java.awt.Insets(0, 0, 0, 0));
        gVectorCB.setName("gVectorCB"); // NOI18N
        gVectorCB.setRolloverEnabled(true);
        gVectorCB.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbr.gif"))); // NOI18N
        gVectorCB.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbrs.gif"))); // NOI18N
        gVectorCB.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbs.gif"))); // NOI18N
        gVectorCB.addItemListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 2.0;
        Options1.add(gVectorCB, gridBagConstraints);

        LabelForBMatrix.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        LabelForBMatrix.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        LabelForBMatrix.setText("Use b Matrix"); // NOI18N
        LabelForBMatrix.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        LabelForBMatrix.setName("LabelForBMatrix"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.weighty = 1.0;
        Options1.add(LabelForBMatrix, gridBagConstraints);

        abscissaOptionbuttonGroup.add(bMatrixCB);
        bMatrixCB.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        bMatrixCB.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\n\n\"Use b Matrix\"  automatically sets \"6\" abscissa and dissables<br>\n\"gamma\", \"gdiff\", \"tdelta\" and \"tDELta\". Note that no unit <br>\nconversion is done. After checking this box, 8 column ascii <br>\ndata can be loaded.  Image pixels can be loaded provided <br>\nthe arraies: bvalrr, bvalpp, bvalss, bvalrp, bvalrs, bvalsp are <br>\npresent in procpar. Note the order of the 6 abscissa in an ASCII<br>\nfile must be as listed above.\n\n\n</font></p><html>\n"); // NOI18N
        bMatrixCB.setContentAreaFilled(false);
        bMatrixCB.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        bMatrixCB.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        bMatrixCB.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rb.gif"))); // NOI18N
        bMatrixCB.setIconTextGap(16);
        bMatrixCB.setMargin(new java.awt.Insets(0, 0, 0, 0));
        bMatrixCB.setName("bMatrixCB"); // NOI18N
        bMatrixCB.setRolloverEnabled(true);
        bMatrixCB.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbr.gif"))); // NOI18N
        bMatrixCB.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbrs.gif"))); // NOI18N
        bMatrixCB.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbs.gif"))); // NOI18N
        bMatrixCB.addItemListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 2.0;
        Options1.add(bMatrixCB, gridBagConstraints);

        labelForBVector.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        labelForBVector.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelForBVector.setText("Use b Vectors"); // NOI18N
        labelForBVector.setHorizontalTextPosition(javax.swing.SwingConstants.LEFT);
        labelForBVector.setName("labelForBVector"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.weighty = 1.0;
        Options1.add(labelForBVector, gridBagConstraints);

        abscissaOptionbuttonGroup.add(bVectorCB);
        bVectorCB.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        bVectorCB.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\"Use b Vectors\" automatically sets \"3\" abscissa and enables <br>\nthe priors for \"gamma\", \"gdiff\", \"tdelta\" and \"tDELta\".  <br>\nThese four parameters are used in converting the units from <br>\ngradients  to \"b\" values and are set from procpar, when available.<br>\nAfter checking this box, 5 column ascii data can be loaded.<br>\nImage pixel data can also be loaded provided three parametes<br>\n are arraied.\n\n\n\n</font></p><html>\n\n"); // NOI18N
        bVectorCB.setContentAreaFilled(false);
        bVectorCB.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        bVectorCB.setHorizontalTextPosition(javax.swing.SwingConstants.LEADING);
        bVectorCB.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rb.gif"))); // NOI18N
        bVectorCB.setIconTextGap(16);
        bVectorCB.setMargin(new java.awt.Insets(0, 0, 0, 0));
        bVectorCB.setName("bVectorCB"); // NOI18N
        bVectorCB.setRolloverEnabled(true);
        bVectorCB.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbr.gif"))); // NOI18N
        bVectorCB.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbrs.gif"))); // NOI18N
        bVectorCB.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/buttons/rbs.gif"))); // NOI18N
        bVectorCB.addItemListener(formListener);
        bVectorCB.addActionListener(formListener);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 2.0;
        Options1.add(bVectorCB, gridBagConstraints);

        jResetSave.setName("jResetSave"); // NOI18N

        org.jdesktop.layout.GroupLayout setup_panelLayout = new org.jdesktop.layout.GroupLayout(setup_panel);
        setup_panel.setLayout(setup_panelLayout);
        setup_panelLayout.setHorizontalGroup(
            setup_panelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(setup_panelLayout.createSequentialGroup()
                .addContainerGap()
                .add(jRun, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 212, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jserver, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 190, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(abscOptionPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 190, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(Options1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 172, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(analysOptionPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 141, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jResetSave, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 115, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(210, Short.MAX_VALUE))
        );
        setup_panelLayout.setVerticalGroup(
            setup_panelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(setup_panelLayout.createSequentialGroup()
                .add(setup_panelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jRun, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 102, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, setup_panelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                        .add(org.jdesktop.layout.GroupLayout.LEADING, analysOptionPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(org.jdesktop.layout.GroupLayout.LEADING, Options1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(org.jdesktop.layout.GroupLayout.LEADING, abscOptionPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .add(jserver, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jResetSave, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );

        setup_panelLayout.linkSize(new java.awt.Component[] {Options1, abscOptionPane, analysOptionPane, jResetSave, jRun, jserver}, org.jdesktop.layout.GroupLayout.VERTICAL);

        jSplitPane1.setLeftComponent(setup_panel);

        graph_panel.setName("graph_panel"); // NOI18N
        graph_panel.setLayout(new javax.swing.BoxLayout(graph_panel, javax.swing.BoxLayout.LINE_AXIS));
        jSplitPane1.setRightComponent(graph_panel);

        add(jSplitPane1, java.awt.BorderLayout.CENTER);
    }

    // Code for dispatching events from components to event handlers.

    private class FormListener implements java.awt.event.ActionListener, java.awt.event.ItemListener {
        FormListener() {}
        public void actionPerformed(java.awt.event.ActionEvent evt) {
            if (evt.getSource() == jTensorComboBox) {
                BayesDiffTensor.this.jTensorComboBoxActionPerformed(evt);
            }
            else if (evt.getSource() == jConstCheckBox) {
                BayesDiffTensor.this.jConstCheckBoxActionPerformed(evt);
            }
            else if (evt.getSource() == bVectorCB) {
                BayesDiffTensor.this.bVectorCBActionPerformed(evt);
            }
        }

        public void itemStateChanged(java.awt.event.ItemEvent evt) {
            if (evt.getSource() == includeOutliersCheckBox) {
                BayesDiffTensor.this.includeOutliersCheckBoxItemStateChanged(evt);
            }
            else if (evt.getSource() == gVectorCB) {
                BayesDiffTensor.this.gVectorCBItemStateChanged(evt);
            }
            else if (evt.getSource() == bMatrixCB) {
                BayesDiffTensor.this.bMatrixCBItemStateChanged(evt);
            }
            else if (evt.getSource() == bVectorCB) {
                BayesDiffTensor.this.bVectorCBItemStateChanged(evt);
            }
        }
    }// </editor-fold>//GEN-END:initComponents

private void jTensorComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTensorComboBoxActionPerformed
    numberOfTensors = (String) getTensorComboBox().getSelectedItem();
    clearPreviousRun();
}//GEN-LAST:event_jTensorComboBoxActionPerformed
private void jConstCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jConstCheckBoxActionPerformed
    constantIsSelected = getConstantCheckBox().isSelected();
    numberOfTensors = (String) getTensorComboBox().getSelectedItem();
    clearPreviousRun();
}//GEN-LAST:event_jConstCheckBoxActionPerformed
private void gVectorCBItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_gVectorCBItemStateChanged
  if (  isPackageLoaded() == false){return;}
  if ( evt.getStateChange() == ItemEvent.SELECTED){
        setAbscissaType(ABSCISSA_TYPE.G_VECTOR);
        //setFromProcpar();
        
        AsciiIO.clearAsciiFileNonCompatibleWithModel(this);

        Component c = AllViewers.getSelectedComponent();
      
        AllViewers.setSelectedComponent(c);


        clearPreviousRun();

       if (JAllPriors.isDisplayed()){
            JAllPriors.updatePriors(getPriors());
        }
   }
}//GEN-LAST:event_gVectorCBItemStateChanged
private void bMatrixCBItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_bMatrixCBItemStateChanged
    if (isPackageLoaded() == false){return;}
    if ( evt.getStateChange() == ItemEvent.SELECTED){
        setAbscissaType(ABSCISSA_TYPE.B_MATRIX);
       AsciiIO.clearAsciiFileNonCompatibleWithModel(this);

        //  boolean isData  =   ASCIIDataViewer.getInstance().isDataLoaded();
     //  if (isData  == false){ resetStaticVariables(); }
        Component c = AllViewers.getSelectedComponent();
        AllViewers.setSelectedComponent(c);

        clearPreviousRun();
       
        if (JAllPriors.isDisplayed()){
            JAllPriors.updatePriors(getPriors());
        }
    }
}//GEN-LAST:event_bMatrixCBItemStateChanged
private void bVectorCBItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_bVectorCBItemStateChanged
    if (isPackageLoaded() == false){return;}
    if ( evt.getStateChange() == ItemEvent.SELECTED){
        setAbscissaType(ABSCISSA_TYPE.B_VECTOR);
        AsciiIO.clearAsciiFileNonCompatibleWithModel(this);


        //  boolean isData  =   ASCIIDataViewer.getInstance().isDataLoaded();
       //  if (isData  == false){ resetStaticVariables(); }
        Component c = AllViewers.getSelectedComponent();

        AllViewers.setSelectedComponent(c);

        clearPreviousRun();


        if (JAllPriors.isDisplayed()){
            JAllPriors.updatePriors(this.getPriors());
        }
   }
}//GEN-LAST:event_bVectorCBItemStateChanged
private void includeOutliersCheckBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_includeOutliersCheckBoxItemStateChanged
    includeOutliers = this.getIncludeOutliersCheckBox().isSelected();

    clearPreviousRun();
}//GEN-LAST:event_includeOutliersCheckBoxItemStateChanged

    private void bVectorCBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bVectorCBActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_bVectorCBActionPerformed

// ***************** Model Interface Methods start *************//  
    public void setPackageParameters(ObjectInputStream serializationFile) throws Exception {


       boolean curConst                 = (Boolean) serializationFile.readObject();
        boolean includeOutlrs           = (Boolean) serializationFile.readObject();
        String curNoTensors             = (String) serializationFile.readObject();
        ABSCISSA_TYPE atype             = (ABSCISSA_TYPE) serializationFile.readObject();

        Lambda1Prior                    =(ParameterPrior)serializationFile.readObject();//0
        Lambda2Prior                    =(ParameterPrior)serializationFile.readObject();//1
        Lambda3Prior                    =(ParameterPrior)serializationFile.readObject();//2
        ThetaPrior                      =(ParameterPrior)serializationFile.readObject();//3
        PhiPrior                        =(ParameterPrior)serializationFile.readObject();//4
        PsiPrior                        =(ParameterPrior)serializationFile.readObject();//5
        gammaPrior                      =(ParameterPrior)serializationFile.readObject();//6
        SmallDeltaPrior                 =(ParameterPrior)serializationFile.readObject();//7
        LargeDeltaPrior                 =(ParameterPrior)serializationFile.readObject();//8
        gdiffPrior                      =(ParameterPrior)serializationFile.readObject();//9
        AmpTensorPrior                  =(ParameterPrior)serializationFile.readObject();//10
        ConstantPrior                   =(ParameterPrior)serializationFile.readObject();//11



        setConstant(curConst);
        setNumberOfTensors(curNoTensors);
        setIncludeOutliers(includeOutlrs);
        setAbscissaType(atype);

    }
    public void savePackageParameters(ObjectOutputStream serializationFile) {
        try {
            serializationFile.writeObject(constantIsSelected);
            serializationFile.writeObject(isIncludeOutliers());
            serializationFile.writeObject(numberOfTensors);
            serializationFile.writeObject(getAbscissaType());


            serializationFile.writeObject(Lambda1Prior);//0
            serializationFile.writeObject(Lambda2Prior);//1
            serializationFile.writeObject(Lambda3Prior);//2
            serializationFile.writeObject(ThetaPrior);//3
            serializationFile.writeObject(PhiPrior);//4
            serializationFile.writeObject(PsiPrior);//5
            serializationFile.writeObject(gammaPrior);//6
            serializationFile.writeObject(SmallDeltaPrior);//7
            serializationFile.writeObject(LargeDeltaPrior);//8
            serializationFile.writeObject(gdiffPrior);//9
            serializationFile.writeObject(AmpTensorPrior);//10
            serializationFile.writeObject(ConstantPrior);//11


            
        } catch (IOException exp) {
            DirectoryManager.getSerializationFile().delete();
        }
    }
    public boolean isReadyToRun() {
        // make sure data has been loaded
        File dir            = DirectoryManager.getBayesOtherAnalysisDir();
        File[] files        = DirectoryManager.getAsciiDataFiles();

        if (files == null || files.length == 0) {
            DisplayText.popupErrorMessage("You must load data before you run the program.");
            return false;
        }

        // make sure all data files exist
        for (File file : files) {
            if (!file.exists()) {
                DisplayText.popupErrorMessage("Data file " + file + "doesn't exist.");
                return false;
            }
        }





        // write the parameter file
        boolean bl = WriteBayesParams.writeParamsFile(this, dir);
        if (bl == false) {
            DisplayText.popupErrorMessage("Failed to write Bayes.params file.");
            return false;
        }

        //  write "job.directions" file
        PackageManager.setCurrentApplication(this);
        bl = JobDirections.writeFromProperties(JobDirections.BAYES_SUBMIT);
        if (bl == false) {
            DisplayText.popupErrorMessage("Failed to write job.directions file.");
            return false;
        }
        return true;

    }
    public List <ParameterPrior>  getPriors() {
        priors.clear();
        switch (getAbscissaType()) {
            case G_VECTOR:
                 priors.add( Lambda1Prior);
                 priors.add( Lambda2Prior);
                 priors.add( Lambda3Prior);
                 priors.add( ThetaPrior);
                 priors.add( PhiPrior);
                 priors.add( PsiPrior);
                 priors.add( gammaPrior);
                 priors.add( SmallDeltaPrior);
                 priors.add( LargeDeltaPrior);
                 priors.add( gdiffPrior);
                 priors.add( AmpTensorPrior);
                 if (constantIsSelected) {  priors.add(ConstantPrior);}
                 break;
            case B_VECTOR:
                 priors.add( Lambda1Prior);
                 priors.add( Lambda2Prior);
                 priors.add( Lambda3Prior);
                 priors.add( ThetaPrior);
                 priors.add( PhiPrior);
                 priors.add( PsiPrior);
                 priors.add( AmpTensorPrior);
                 if (constantIsSelected) {  priors.add(ConstantPrior);}
                 break;

            case B_MATRIX:
                 priors.add( Lambda1Prior);
                 priors.add( Lambda2Prior);
                 priors.add( Lambda3Prior);
                 priors.add( ThetaPrior);
                 priors.add( PhiPrior);
                 priors.add( PsiPrior);
                 priors.add( AmpTensorPrior);
                 if (constantIsSelected) {  priors.add(ConstantPrior);}
                 break;
        }

        return priors;
    }
    public int              getNumberOfDataColumns() {
        return 1;
    }
    public int              getNumberOfAbscissa() {
       return getAbscissaType().getAbscissaNumber();
    }
    public int              getTotalNumberOfColumns() {
        return  getNumberOfAbscissa() + 2 ;
    }
    public int              getNumberOfPriors() {
        return getPriors().size();
    }
    public StringBuilder    getModelSpecificsForParamsFile(int PADLEN, String PADCHAR) {
        StringBuilder buffer = new StringBuilder();
        buffer.append(EOL);

        buffer.append (IO.pad("Package Parameters", -PADLEN, PADCHAR ));
        buffer.append(" = "+ "2");
        buffer.append(EOL);

        buffer.append (IO.pad("Number of Tensors", -PADLEN, PADCHAR ));
        buffer.append(" = "+ numberOfTensors);
        buffer.append(EOL);

        String str = (constantIsSelected) ? "YES" : "NO";
        buffer.append (IO.pad("Constant", -PADLEN, PADCHAR ));
        buffer.append(" = "+ str);
        buffer.append(EOL);

        str         =   getAbscissaType().getString();
        buffer.append (IO.pad("Abscissa Type", -PADLEN, PADCHAR ));
        buffer.append(" = "+ str);
        buffer.append(EOL);


        return buffer;
    }
    public String           getProgramName() {
        return "BayesDiffTensor";
    }
    public String           getExtendedProgramName() {
        return "Diffusion Tensor Package";
    }
    public String               getConstructorArg() {
        return null;
    }
    public String               getInstructions() {
        return PACKAGE_INTSRUCTIONS.DIFFUSION_TESNOR.getInstruction();
    }
    public boolean              isOutliers() {
        return  isIncludeOutliers();
    }
    public void                 reset() {
        setDefaults();

        clearPreviousRun();
        // show defualt viewer
        AllViewers.getInstance().showDefaultViewer();
    }
    public void              clearPreviousRun(){
        // clear outputs of previous run
         Reset.clearAsciiResutls();

         // reset job status
         jRun.reset();

    }
    public void              setDefaults(){
       
        setAbscissaType(ABSCISSA_TYPE.G_VECTOR);

        setIncludeOutliers(false);
        getIncludeOutliersCheckBox().setSelected(this.isIncludeOutliers());


        numberOfTensors         = "1";
        getTensorComboBox().setEnabled(true);
        getTensorComboBox().setSelectedItem(numberOfTensors);
        

        constantIsSelected      = false;
        getConstantCheckBox().setEnabled(true);
        getConstantCheckBox().setSelected(constantIsSelected);
    }

    public void                 setActive(boolean enabled) {
        AllViewers.getInstance().setActive(enabled);
        getTensorComboBox().setEnabled(enabled);
        getConstantCheckBox().setEnabled(enabled);
        jserver.setActive(enabled);
        jRun.setEnabled(enabled);
        jResetSave.setEnabled(enabled);
        includeOutliersCheckBox.setEnabled(enabled);
        getbMatrixCB().setEnabled(enabled);
        getbVectorCB().setEnabled(enabled);
        getgVectorCB().setEnabled(enabled);
        getLabelForBVector().setEnabled(enabled);
        getLabelForGVector().setEnabled(enabled);
        getLabelForBMatrix() .setEnabled(enabled);
        includeOutliersLabel.setEnabled(enabled);
        includeConstantLabel.setEnabled(enabled);
        tensorNumberLabel.setEnabled(enabled);

    }
    public void                 propertyChange(java.beans.PropertyChangeEvent evt) {

        if (evt.getPropertyName().equals(bayes.BayesManager.JRUN_JOB_START)) {
            setActive(false);
        } else if (evt.getPropertyName().equals(bayes.BayesManager.JRUN_JOB_END)) {
            setActive(true);
            AllViewers.showResultsViewer();
        } else if (evt.getPropertyName().equals(bayes.BayesManager.JRUN_JOB_CANCELED)) {
            setActive(true);
        }

    }


    public void setFromProcpar() {
        if (getPriors() == null){return;}
        File file       = DirectoryManager.getImageProcparFile();

        String message = null;


        if (file.exists() == false) {
            return;
            /*
            JFileChooser fc = new JFileChooser();
            fc.setDialogTitle("Load Procpar for Diffusion Tensor FID");
            fc.setMultiSelectionEnabled(false);
            fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
            fc.setFileFilter(new BayesFileFilters.ProcparFileChooserFilter());

            int returnVal = fc.showOpenDialog(null);

            if (returnVal == JFileChooser.APPROVE_OPTION) {
                file = fc.getSelectedFile();

            } else {
                return;
            }*/
        }




        Procpar procpar = new Procpar(file);

        if (procpar.isImage() == false) {
            message = String.format(
                    "Procpar %s  \n" +
                    "is not an image procpar file.\n" +
                    "Exit prior assignments...",
                    file.getPath());
            DisplayText.popupErrorMessage(message);

        }

        if (procpar == null) {
            DisplayText.popupErrorMessage("Failed to parse procpar file.\n" +
                                          "Priors are not updated.");
            return;
        }


        // resetStaticVariables gamma to default
        gammaPrior.low = GYRIMAGNETIC_RATIO_WATER;
        gammaPrior.high = GYRIMAGNETIC_RATIO_WATER;
        gammaPrior.mean = GYRIMAGNETIC_RATIO_WATER;




        // String f  = "%1.4E";
        StringBuilder buffer = new StringBuilder();

        if (procpar.getGdiff().isNaN() == true) {
            buffer.append("Failed to write gdiff from procpar.\n");
        } else {
            double gdiff            =   procpar.getGdiff();
             gdiffPrior.mean        =   gdiff;
             gdiffPrior.low         =   gdiff;
             gdiffPrior.high        =   gdiff;
        }

        if (procpar.getTdelta().isNaN() == true) {
            buffer.append("Failed to write tdelta from procpar.\n");
        } else {
            double tdelta = procpar.getTdelta();
            SmallDeltaPrior.mean    =   tdelta;
            SmallDeltaPrior.low     =   tdelta;
            SmallDeltaPrior.high    =   tdelta;
        }


        if (procpar.getTDELTA().isNaN() == true) {
            buffer.append("Failed to write TDELTA from procpar.\n");
        }
        {
            double tDELTA           = procpar.getTDELTA() ;
            LargeDeltaPrior.mean    = tDELTA;
            LargeDeltaPrior.low     = tDELTA;
            LargeDeltaPrior.high    = tDELTA;
        }

        if (buffer.length() > 0) {
            DisplayText.popupErrorMessage(buffer.toString());
        }

        clearPreviousRun();
        AllViewers.showPriorsViewer();
    }

    public static void createAndShowGUI() {

        //Create and set up the window.
        JFrame frame = new JFrame(" Diffusion Tensor Model");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.addWindowListener(new java.awt.event.WindowAdapter() {

            @Override
            public void windowClosing(java.awt.event.WindowEvent evt) {
                DirectoryManager.shutDownDirectory();
            }
        });

        frame.add(new BayesDiffTensor());

        //Display the window.
        frame.pack();
        frame.setVisible(true);
    }

    public static void main(String[] args) {
        //Schedule a job for the event-dispatching thread:
        //creating and showing this application's GUI.
        javax.swing.SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                createAndShowGUI();
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel LabelForBMatrix;
    private javax.swing.JPanel Options1;
    private javax.swing.JPanel abscOptionPane;
    private javax.swing.ButtonGroup abscissaOptionbuttonGroup;
    private javax.swing.JPanel analysOptionPane;
    public javax.swing.JCheckBox bMatrixCB;
    public javax.swing.JCheckBox bVectorCB;
    public javax.swing.JCheckBox gVectorCB;
    private javax.swing.JPanel graph_panel;
    private javax.swing.JLabel includeConstantLabel;
    public javax.swing.JCheckBox includeOutliersCheckBox;
    private javax.swing.JLabel includeOutliersLabel;
    public javax.swing.JCheckBox jConstCheckBox;
    private javax.swing.JLabel jLabel11;
    private javax.swing.JLabel jLabel7;
    private interfacebeans.JResetSave jResetSave;
    private run.JRun jRun;
    private javax.swing.JSplitPane jSplitPane1;
    public javax.swing.JComboBox jTensorComboBox;
    private interfacebeans.JServer jserver;
    private javax.swing.JLabel labelForBVector;
    private javax.swing.JLabel labelForGVector;
    private javax.swing.JPanel setup_panel;
    private javax.swing.JLabel tensorNumberLabel;
    // End of variables declaration//GEN-END:variables

    public javax.swing.JCheckBox getIncludeOutliersCheckBox() {
        return includeOutliersCheckBox;
    }
    public javax.swing.JCheckBox getbMatrixCB() {
        return bMatrixCB;
    }
    public javax.swing.JCheckBox getbVectorCB() {
        return bVectorCB;
    }
    public javax.swing.JCheckBox getgVectorCB() {
        return gVectorCB;
    }
    public javax.swing.JLabel getLabelForBVector() {
        return labelForBVector;
    }
    public javax.swing.JLabel getLabelForGVector() {
        return labelForGVector;
    }
    public javax.swing.JLabel getLabelForBMatrix() {
        return LabelForBMatrix;
    }
    public javax.swing.JCheckBox getConstantCheckBox() {
        return jConstCheckBox;
    }
    public javax.swing.JComboBox getTensorComboBox() {
        return jTensorComboBox;
    }

    public List<ParameterPrior> initializePriors() {
      List<ParameterPrior> prs = new ArrayList <ParameterPrior>();
      try {

        double gdiff                            =   10;
        double tdelta                           =   0.005;
        double tDELTA                           =   0.05;
  

        Lambda1Prior                    = new ParameterPrior("Lambda1");
        ParameterPrior prior            = Lambda1Prior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low                   = 0;
            prior.high                  = 5E-3;
            prior.mean                  = 1E-4;
            prior.sdev                  = 1E-4;
            prior.priorType             = PRIOR_TYPE.POSITIVE;
            prior.order                 = ORDER_TYPE.HighLow;
            prior.setParameterType(PARAMETER_TYPE.NonLinear);
            prior.isOrderEditable       = false;
            prior.isPriorTypeEditable   = true;
            prior.isPriorEditable       = false;
        }


        Lambda2Prior = new ParameterPrior("Lambda2");
        prior = Lambda2Prior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low                   = 0;
            prior.high                  = 5E-3;
            prior.mean                  = 1E-4;
            prior.sdev                  = 1E-4;
            prior.priorType             = PRIOR_TYPE.POSITIVE;
            prior.order                 = ORDER_TYPE.HighLow;
            prior.setParameterType(PARAMETER_TYPE.NonLinear);
            prior.isOrderEditable       = false;
            prior.isPriorTypeEditable   = true;
            prior.isPriorEditable       = false;
        }



        Lambda3Prior = new ParameterPrior("Lambda3");
        prior = Lambda3Prior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low                   = 0;
            prior.high                  = 5E-3;
            prior.mean                  = 1E-4;
            prior.sdev                  = 1E-4;
            prior.priorType             = PRIOR_TYPE.POSITIVE;
            prior.order                 = ORDER_TYPE.HighLow;
            prior.setParameterType(PARAMETER_TYPE.NonLinear);
            prior.isOrderEditable       = false;
            prior.isPriorTypeEditable   = true;
            prior.isPriorEditable       = false;
        }

        ThetaPrior  = new ParameterPrior("Theta");
        prior       = ThetaPrior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low = 0;
            prior.high = 180;
            prior.mean = (prior.low + prior.high) / 2;
            prior.sdev = (prior.high - prior.low) / 3;
            prior.priorType = PRIOR_TYPE.UNIFORM;
            prior.order = ORDER_TYPE.NotOrdered;
            prior.setParameterType(PARAMETER_TYPE.NonLinear);
            prior.isOrderEditable = false;
            prior.isPriorTypeEditable = false;
            prior.isPriorEditable = false;
        }


        PhiPrior    = new ParameterPrior("Phi");
        prior       = PhiPrior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low = 0;
            prior.high = 180;
            prior.mean = (prior.low + prior.high) / 2;
            prior.sdev = (prior.high - prior.low) / 3;
            prior.priorType = PRIOR_TYPE.UNIFORM;
            prior.order = ORDER_TYPE.NotOrdered;
            prior.setParameterType(PARAMETER_TYPE.NonLinear);
            prior.isOrderEditable = false;
            prior.isPriorTypeEditable = false;
            prior.isPriorEditable = false;
        }




        PsiPrior = new ParameterPrior("Psi");
        prior   = PsiPrior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low = 0;
            prior.high = 180;
            prior.mean = (prior.low + prior.high) / 2;
            prior.sdev = (prior.high - prior.low) / 3;
            prior.priorType = PRIOR_TYPE.UNIFORM;
            prior.order = ORDER_TYPE.NotOrdered;
            prior.setParameterType(PARAMETER_TYPE.NonLinear);
            prior.isOrderEditable = false;
            prior.isPriorTypeEditable = false;
            prior.isPriorEditable = false;
        }


        gammaPrior  = new ParameterPrior("gamma");
        prior       = gammaPrior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low                   = GYRIMAGNETIC_RATIO_WATER;
            prior.high                  = GYRIMAGNETIC_RATIO_WATER;
            prior.mean                  = GYRIMAGNETIC_RATIO_WATER;
            prior.sdev                  = 0;
            prior.priorType             = PRIOR_TYPE.FIXED_PARAMETER;
            prior.order                 = ORDER_TYPE.NotOrdered;
            prior.setParameterType(PARAMETER_TYPE.Parameter);
            prior.isOrderEditable       = false;
            prior.isPriorTypeEditable   = false;
            prior.isPriorEditable       = true;
        }


        SmallDeltaPrior = new ParameterPrior("SmallDelta");
        prior           = SmallDeltaPrior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low = tdelta;
            prior.high = tdelta;
            prior.mean = (prior.low + prior.high) / 2;
            prior.sdev = 0.005;
            prior.priorType = PRIOR_TYPE.FIXED_PARAMETER;
            prior.order = ORDER_TYPE.NotOrdered;
            prior.setParameterType(PARAMETER_TYPE.Parameter);
            prior.isOrderEditable = false;
            prior.isPriorTypeEditable = false;
            prior.isPriorEditable = false;
        }

        LargeDeltaPrior = new ParameterPrior("LargeDelta");
        prior           = LargeDeltaPrior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low = tDELTA;
            prior.high = tDELTA;
            prior.mean = (prior.low + prior.high) / 2;
            prior.sdev = 0.05;
            prior.priorType = PRIOR_TYPE.FIXED_PARAMETER;
            prior.order = ORDER_TYPE.NotOrdered;
            prior.setParameterType(PARAMETER_TYPE.Parameter);
            prior.isOrderEditable = false;
            prior.isPriorTypeEditable = false;
            prior.isPriorEditable = false;
        }


        gdiffPrior = new ParameterPrior("gdiff");
        prior = gdiffPrior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.low                   = gdiff;
            prior.high                  = gdiff;
            prior.mean                  = (prior.low + prior.high) / 2;
            prior.sdev                  = 10;
            prior.priorType             = PRIOR_TYPE.FIXED_PARAMETER;
            prior.order                 = ORDER_TYPE.NotOrdered;
            prior.setParameterType(PARAMETER_TYPE.Parameter);
            prior.isOrderEditable       = false;
            prior.isPriorTypeEditable   = false;
            prior.isPriorEditable       = false;
        }



        AmpTensorPrior = new ParameterPrior("AmpTensor");
        prior           = AmpTensorPrior;
        prs.add(prior);
        if (prior.isPriorEditable == true) {
            prior.setParameterType(PARAMETER_TYPE.Amplitude);
        }

        ConstantPrior                   = new ParameterPrior("Constant");
        prior                           = ConstantPrior;
        if (prior.isPriorEditable == true) {
            prior.setParameterType(PARAMETER_TYPE.Amplitude);
        }
       } catch (Exception ex) {
            ex.printStackTrace();
        }
        finally{
            return prs;
        }
        
    }

    public void setConstant(boolean isConstant) {
        constantIsSelected = isConstant;
        if (getConstantCheckBox() != null) {
            getConstantCheckBox().setSelected(constantIsSelected);
        }
    }
    public void setNumberOfTensors(String curNoTensors) {
        numberOfTensors = curNoTensors;
        if (getTensorComboBox() != null) {
            getTensorComboBox().setSelectedItem(numberOfTensors);
        }
    }
    public boolean isIncludeOutliers() {
        return includeOutliers;
    }
   
    public void setIncludeOutliers(boolean includeOutliers) {
        this.includeOutliers = includeOutliers;
        if (getIncludeOutliersCheckBox() != null) {
            getIncludeOutliersCheckBox().setSelected(includeOutliers);
        }
    }

    public ABSCISSA_TYPE    getAbscissaType() {
        return abscissaType;
    }
    public void             setAbscissaType(ABSCISSA_TYPE abscissaType) {
        this.abscissaType = abscissaType;

        switch (abscissaType) {
            case G_VECTOR:
                if (getgVectorCB()!= null){
                        getgVectorCB().setSelected(true);
                }
                break;
            case B_VECTOR:
                if ( getbVectorCB()!= null){
                        getbVectorCB().setSelected(true);
                }
                break;

            case B_MATRIX:
                if ( getbMatrixCB()!= null){
                        getbMatrixCB().setSelected(true);
                }
                break;
        }


    }

    public boolean isPackageLoaded() {
        return isLoaded;
    }
    public void setPackageIsLoaded(boolean isLoaded) {
        this.isLoaded = isLoaded;
    }
}
    
    
