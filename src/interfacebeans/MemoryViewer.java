/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * MemoryViewer.java
 *
 * Created on Jan 19, 2011, 1:47:33 PM
 */

package interfacebeans;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.Window;
import java.awt.event.ItemEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import javax.swing.JFrame;
import javax.swing.JPanel;

/**
 *
 * @author apple
 */
public class MemoryViewer extends javax.swing.JPanel {
    public static enum UNITS {
        KB("KB", 1024),
        MB("MB", 1024*1024);
        private String name;
        private long   conversion;
        UNITS(String name, long conversion){
            this.name           = name;
            this.conversion     = conversion;
        }

        /**
         * @return the name
         */
        @Override
        public String toString() {
            return name;
        }

        /**
         * @return the conversion
         */
        public long getConversion() {
            return conversion;
        }
        };
    private static final long serialVersionUID      = 617003337631125L;
    private static  MemoryViewer   instance         = null;
    private UNITS   units                           = UNITS.MB;
    public long sleepAmountDef                       = 100;
    boolean roundUnits                               = true;
    JFrame window                                    =  null;

    public Surface surf;
    /** Creates new form MemoryMonitor */
    /** Creates new form MemoryMonitor */
    public static MemoryViewer getInstance() {
       if (instance == null){
         instance    = new  MemoryViewer();
       }
       return instance;
    }


    /** Creates new form MemoryViewer */
    private MemoryViewer() {
        initComponents();
        mainPane.setLayout(new BorderLayout());
        mainPane.add(surf = new Surface());
    }

    public static void main(String s[]) {
       showMemoryMonitor();
    }
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        roundUnitsCheckBox = new javax.swing.JCheckBox();
        upperPane = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        availableMemroyTF = new javax.swing.JTextField();
        usedMemoryTF = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        maxMemroyTF = new javax.swing.JTextField();
        unitsComboBox = new javax.swing.JComboBox(UNITS.values());
        lowerPane = new javax.swing.JPanel();
        updateTimeSpinner = new javax.swing.JSpinner();
        jLabel4 = new javax.swing.JLabel();
        freeUpMemoryButton = new javax.swing.JButton();
        mainPane = new javax.swing.JPanel();

        roundUnitsCheckBox.setSelected(this.roundUnits);
        roundUnitsCheckBox.setText("Round");
        roundUnitsCheckBox.setName("roundUnitsCheckBox"); // NOI18N
        roundUnitsCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                roundUnitsCheckBoxActionPerformed(evt);
            }
        });

        setLayout(new java.awt.BorderLayout());

        upperPane.setName("upperPane"); // NOI18N
        upperPane.setLayout(new java.awt.GridBagLayout());

        jLabel1.setText("Free");
        jLabel1.setName("jLabel1"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        upperPane.add(jLabel1, gridBagConstraints);

        jLabel2.setText("Used");
        jLabel2.setName("jLabel2"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        upperPane.add(jLabel2, gridBagConstraints);

        availableMemroyTF.setEditable(false);
        availableMemroyTF.setName("availableMemroyTF"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
        upperPane.add(availableMemroyTF, gridBagConstraints);

        usedMemoryTF.setEditable(false);
        usedMemoryTF.setName("usedMemoryTF"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
        upperPane.add(usedMemoryTF, gridBagConstraints);

        jLabel3.setText("Max");
        jLabel3.setName("jLabel3"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        upperPane.add(jLabel3, gridBagConstraints);

        maxMemroyTF.setEditable(false);
        maxMemroyTF.setName("maxMemroyTF"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
        upperPane.add(maxMemroyTF, gridBagConstraints);

        unitsComboBox.setSelectedItem(units);
        unitsComboBox.setName("unitsComboBox"); // NOI18N
        unitsComboBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                unitsComboBoxItemStateChanged(evt);
            }
        });
        upperPane.add(unitsComboBox, new java.awt.GridBagConstraints());

        add(upperPane, java.awt.BorderLayout.NORTH);

        lowerPane.setBackground(new java.awt.Color(0, 0, 0));
        lowerPane.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED, java.awt.Color.black, java.awt.Color.darkGray, java.awt.Color.darkGray, null));
        lowerPane.setName("lowerPane"); // NOI18N
        lowerPane.setLayout(new java.awt.GridBagLayout());

        updateTimeSpinner.setModel(new javax.swing.SpinnerNumberModel(100, 100, 1000, 50));
        updateTimeSpinner.setValue(sleepAmountDef);
        updateTimeSpinner.setName("updateTimeSpinner"); // NOI18N
        updateTimeSpinner.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                updateTimeSpinnerStateChanged(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        lowerPane.add(updateTimeSpinner, gridBagConstraints);

        jLabel4.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        jLabel4.setForeground(new java.awt.Color(255, 255, 255));
        jLabel4.setText("Update (ms)");
        jLabel4.setName("jLabel4"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 5);
        lowerPane.add(jLabel4, gridBagConstraints);

        freeUpMemoryButton.setText("Free Up Memory");
        freeUpMemoryButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nRuns the  java garbage collector. <br>\n<br>\nCalling the garbage collector  suggests that the Java Virtual Machine <br>\nexpend effort toward recycling unused objects in order to make <br>\nthe memory they currently occupy available for quick reuse. <br>\nWhen control returns from the method call, the Java Virtual Machine <br>\nhas made a best effort to reclaim space from all discarded objects.\n\n</font></p><html>"); // NOI18N
        freeUpMemoryButton.setName("freeUpMemoryButton"); // NOI18N
        freeUpMemoryButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                freeUpMemoryButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        lowerPane.add(freeUpMemoryButton, gridBagConstraints);

        add(lowerPane, java.awt.BorderLayout.SOUTH);

        mainPane.setName("mainPane"); // NOI18N

        org.jdesktop.layout.GroupLayout mainPaneLayout = new org.jdesktop.layout.GroupLayout(mainPane);
        mainPane.setLayout(mainPaneLayout);
        mainPaneLayout.setHorizontalGroup(
            mainPaneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 400, Short.MAX_VALUE)
        );
        mainPaneLayout.setVerticalGroup(
            mainPaneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 237, Short.MAX_VALUE)
        );

        add(mainPane, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents

    private void unitsComboBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_unitsComboBoxItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED){
            units = (UNITS)unitsComboBox.getSelectedItem();
        }

    }//GEN-LAST:event_unitsComboBoxItemStateChanged

    private void updateTimeSpinnerStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_updateTimeSpinnerStateChanged
         int value = (Integer)updateTimeSpinner.getValue();
         if (surf != null){
            surf.sleepAmount = value;
         }
    }//GEN-LAST:event_updateTimeSpinnerStateChanged

    private void roundUnitsCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_roundUnitsCheckBoxActionPerformed
     roundUnits    = roundUnitsCheckBox.isSelected();
    }//GEN-LAST:event_roundUnitsCheckBoxActionPerformed

    private void freeUpMemoryButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_freeUpMemoryButtonActionPerformed
        System.gc();
    }//GEN-LAST:event_freeUpMemoryButtonActionPerformed
      public static void showMemoryMonitor() {
        final MemoryViewer demo = getInstance();

        if (  demo.window  != null){
              demo.window .toFront();
        }
        else{
            demo.window                = new JFrame("MemoryMonitor");
            WindowListener l        = new WindowAdapter() {
            public void windowClosing(WindowEvent e) {
                demo.surf.stop();
                demo.window = null;

            }
            public void windowDeiconified(WindowEvent e) { demo.surf.start(); }
            public void windowIconified(WindowEvent e) { demo.surf.stop(); }
            };
            demo.window.addWindowListener(l);
            demo.window.getContentPane().add("Center", demo);
            demo.window.setResizable(false);
            demo.window.pack();
            demo.window.setSize(new Dimension(500,400));
            demo.window.setVisible(true);
            demo.surf.start();
            
        }
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextField availableMemroyTF;
    private javax.swing.JButton freeUpMemoryButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel lowerPane;
    private javax.swing.JPanel mainPane;
    private javax.swing.JTextField maxMemroyTF;
    private javax.swing.JCheckBox roundUnitsCheckBox;
    private javax.swing.JComboBox unitsComboBox;
    private javax.swing.JSpinner updateTimeSpinner;
    private javax.swing.JPanel upperPane;
    private javax.swing.JTextField usedMemoryTF;
    // End of variables declaration//GEN-END:variables
      public class Surface extends JPanel implements Runnable {
         private static final long serialVersionUID = 6170037639785281128L;
        public Thread thread;

        public long sleepAmount                                 = sleepAmountDef ;
        private int w, h;
        private BufferedImage bimg;
        private Graphics2D big;
        private Font font = new Font("Times New Roman", Font.BOLD, 16);
        private Runtime r = Runtime.getRuntime();
        private int columnInc;
        private int pts[];
        private int ptNum;
        private int ascent, descent;
        private double freeMemory, totalMemory, usedMemory, maxMemory ,maxMemoryBytes, freeMemoryBytes,totalMemoryBytes;
        private Rectangle graphOutlineRect = new Rectangle();
        private Rectangle2D mfRect = new Rectangle2D.Float();
        private Rectangle2D muRect = new Rectangle2D.Float();
        private Line2D graphLine = new Line2D.Float();
        private Color graphColor = new Color(46, 139, 87);
        private Color mfColor = new Color(0, 100, 0);
        private String usedStr;


        public Surface() {
            setBackground(Color.black);
            addMouseListener(new MouseAdapter() {
                public void mouseClicked(MouseEvent e) {
                    if (thread == null) {
                        start();
                    }else{
                        stop();
                    }
                }
            });
        }

        @Override
        public Dimension getMinimumSize() {
            return getPreferredSize();
        }
        @Override
        public Dimension getMaximumSize() {
            return getPreferredSize();
        }
        @Override
        public Dimension getPreferredSize() {
            return new Dimension(135,80);
        }

        public void updateMemory(){
            freeMemoryBytes             =  (float)r.freeMemory();
            totalMemoryBytes            =  (float)r.totalMemory();
            maxMemoryBytes              =  (float) r.maxMemory();
           
            double conversion           =    1.0*units.getConversion();

            maxMemory                   =   maxMemoryBytes /conversion ;
            freeMemory                  =   freeMemoryBytes/conversion ;
            totalMemory                 =   totalMemoryBytes/conversion ;
            usedMemory                  =   (totalMemoryBytes -  freeMemoryBytes)/conversion ;


            String maxMemoryStr = "", usedMemoryStr = "",availableMemoryStr ="";
            if ( roundUnits ){
                maxMemoryStr            += (int) maxMemory;
                usedMemoryStr           += (int) usedMemory;
                availableMemoryStr      += (int) freeMemory ;
            }
            else{
                maxMemoryStr            += maxMemory;
                usedMemoryStr           += usedMemory;
                availableMemoryStr      += freeMemory ;
            }

            maxMemroyTF.setText(maxMemoryStr);
            usedMemoryTF.setText(usedMemoryStr);
            availableMemroyTF.setText(availableMemoryStr   );
        }
        @Override
        public void paint(Graphics g) {

            if (big == null) {
                return;
            }
        

            big.setBackground(getBackground());
            big.clearRect(0,0,w,h);


            // .. Draw allocated and used strings ..
            big.setColor(Color.green);
            big.drawString(String.valueOf((int)totalMemory ) +" "+units.toString() + " allocated",  4.0f, (float) ascent+0.5f);
            usedStr = (int)usedMemory  + " "+units.toString()+" used";
            big.drawString(usedStr, 4, h - descent);

            // Calculate remaining size
            float ssH = ascent + descent;
            float remainingHeight = (float) (h - (ssH*2) - 0.5f);
            float blockHeight = remainingHeight/10;
            float blockWidth = 20.0f;

            // .. Memory Free ..
            big.setColor(mfColor);
            int MemUsage = (int) ((freeMemoryBytes / totalMemoryBytes) * 10);
            int i = 0;
            for ( ; i < MemUsage ; i++) {
                mfRect.setRect(5,(float) ssH+i*blockHeight,
                                blockWidth,(float) blockHeight-1);
                big.fill(mfRect);
            }

            // .. Memory Used ..
            big.setColor(Color.green);
            for ( ; i < 10; i++)  {
                muRect.setRect(5,(float) ssH+i*blockHeight,
                                blockWidth,(float) blockHeight-1);
                big.fill(muRect);
            }

            // .. Draw History Graph ..
            big.setColor(graphColor);
            int graphX = 30;
            int graphY = (int) ssH;
            int graphW = w - graphX - 5;
            int graphH = (int) remainingHeight;
            graphOutlineRect.setRect(graphX, graphY, graphW, graphH);
            big.draw(graphOutlineRect);

            int graphRow = graphH/10;

            // .. Draw row ..
            for (int j = graphY; j <= graphH+graphY; j += graphRow) {
                graphLine.setLine(graphX,j,graphX+graphW,j);
                big.draw(graphLine);
            }

            // .. Draw animated column movement ..
            int graphColumn = graphW/15;

            if (columnInc == 0) {
                columnInc = graphColumn;
            }

            for (int j = graphX+columnInc; j < graphW+graphX; j+=graphColumn) {
                graphLine.setLine(j,graphY,j,graphY+graphH);
                big.draw(graphLine);
            }

            --columnInc;

            if (pts == null) {
                pts = new int[graphW];
                ptNum = 0;
            } else if (pts.length != graphW) {
                int tmp[] = null;
                if (ptNum < graphW) {
                    tmp = new int[ptNum];
                    System.arraycopy(pts, 0, tmp, 0, tmp.length);
                } else {
                    tmp = new int[graphW];
                    System.arraycopy(pts, pts.length-tmp.length, tmp, 0, tmp.length);
                    ptNum = tmp.length - 2;
                }
                pts = new int[graphW];
                System.arraycopy(tmp, 0, pts, 0, tmp.length);
            } else {
                big.setColor(Color.yellow);
                int val    = (int)(graphY+graphH*(freeMemoryBytes/totalMemoryBytes));
                pts[ptNum] = val;

                for (int j=graphX+graphW-ptNum, k=0;k < ptNum; k++, j++) {
                    if (k != 0) {
                        if (pts[k] != pts[k-1]) {
                            big.drawLine(j-1, pts[k-1], j, pts[k]);
                        } else {
                            big.fillRect(j, pts[k], 1, 1);
                        }
                    }
                }
                if (ptNum+2 == pts.length) {
                    // throw out oldest point
                    for (int j = 1;j < ptNum; j++) {
                        pts[j-1] = pts[j];
                    }
                    --ptNum;
                } else {
                    ptNum++;
                }
            }
            g.drawImage(bimg, 0, 0, this);
        }
         public void start() {
            thread = new Thread(this);
            thread.setPriority(Thread.MIN_PRIORITY);
            thread.setName("MemoryMonitor");
            thread.start();
        }
        public synchronized void stop() {
            thread = null;
            notify();
        }
        public void run() {
            Thread me = Thread.currentThread();
           
            
            while (thread == me && !isShowing() || getSize().width == 0) {
                try {
                    thread.sleep(500);
                } catch (InterruptedException e) { return; }
            }

            while (thread == me && isShowing()) {
                Dimension d = getSize();

              if ( d.width != w || d.height != h) {
                w = d.width;
                h = d.height;
                bimg = (BufferedImage) createImage(w, h);
                big = bimg.createGraphics();
                big.setFont(font);
                FontMetrics fm = big.getFontMetrics(font);
                ascent = (int) fm.getAscent();
                descent = (int) fm.getDescent();
              }
                    updateMemory();
                repaint();
              
               
                try {
                    thread.sleep(sleepAmount);
                } catch (InterruptedException e) { break; }
               
            }
            thread = null;
        }
    }
}
