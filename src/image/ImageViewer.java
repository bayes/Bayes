/*
 * ImageViewer.java
 *
 * Created on March 10, 2008, 4:16 PM
 */
package image;

import bayes.PackageManager;
import bayes.BayesManager;
import bayes.DirectoryManager;
import java.io.*;
import java.text.*;
import java.util.*;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.Frame;
import ascii.*;
import ascii.AsciiDescriptor.SOURCE_TYPE;
import javax.swing.*;

import utilities.*;
import applications.model.*;
import interfacebeans.AllViewers;
import bayes.JPreferences;
import ij.*;
import ij.io.*;
import interfacebeans.Viewable;
import interfacebeans.Viewer;
import java.awt.Image;
import java.awt.Window;


/**
 *
 * @author  apple
 */
public class ImageViewer extends javax.swing.JPanel  implements java.beans.PropertyChangeListener, Viewable {
    public final static String IMAGE_HAS_BEEN_LOADED        = "Image Has Been Loaded";
    public final static String IMAGEJ_IO_JAR_NAME           = "IMG_READER.jar";
    public final static String IMAGEJ_PLUGIN_JAR            = "/image/"+IMAGEJ_IO_JAR_NAME;
    public static   Font imageListfont                      = ImageViewerPreferences.getImageListFont();
    private static ImageViewer instance                     =  null;
    private File roiDir                                     =  null;

    private ImageViewer() {
        initComponents();

        updateImage ();

        BayesManager.pcs.addPropertyChangeListener(this);
    }
    public static ImageViewer getInstance() {
        if (instance == null) {
            instance = new ImageViewer();
        }
        return instance;
    }
    
    public void deserialize(ObjectInputStream serializationFile)
    {
        ignoreEvents = true;
        setIsDeserilized(false);
        try{
            setIsDeserilized(true);
        }
        catch (Exception exp){ exp.printStackTrace();return ;}
        finally{
             ignoreEvents    = false;
        } 
    }
    
    public void serialize(ObjectOutputStream serializationFile) throws IOException
     {  
           
       
    }
     public Component getMainDisplay(){return this.imagePane;}
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;
        bindingGroup = new org.jdesktop.beansbinding.BindingGroup();

        roiType = new javax.swing.ButtonGroup();
        jSplitPane1 = new javax.swing.JSplitPane();
        imageListPane = new javax.swing.JPanel();
        jScrollPane2 = new javax.swing.JScrollPane();
        imageJList = new javax.swing.JList();
        setup_pane = new javax.swing.JPanel();
        slice_label = new javax.swing.JLabel();
        element_label = new javax.swing.JLabel();
        slice_ftxt = new javax.swing.JFormattedTextField(intFormat);
        element_ftxt = new javax.swing.JFormattedTextField(intFormat);
        slice_slider = new javax.swing.JSlider();
        element_slider = new javax.swing.JSlider();
        sliceMaxLabel = new javax.swing.JLabel();
        elementMaxLabel = new javax.swing.JLabel();
        imageScrollPanel = new javax.swing.JScrollPane();
        imahgeAndSettingsScrollPamel = new javax.swing.JPanel();
        ImageAndCalibrationBar = new javax.swing.JPanel();
        imagePane = new image.ImagePane();
        paddedCalibrationBar = new javax.swing.JPanel();
        calibrationBar = new image.JCalibrationBar();
        toolpane = new javax.swing.JPanel();
        PixelInfoPane = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        textField1 = new javax.swing.JFormattedTextField();
        textField2 = new javax.swing.JFormattedTextField();
        textField3 = new javax.swing.JFormattedTextField();
        statPane = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        getStatsButton = new javax.swing.JButton();
        roiMeanTF = new javax.swing.JFormattedTextField();
        roiMaxTF = new javax.swing.JFormattedTextField();
        roiMinTF = new javax.swing.JFormattedTextField();
        roiSdevTF = new javax.swing.JFormattedTextField();
        roiRmsTF = new javax.swing.JFormattedTextField();
        saveStatsButton = new javax.swing.JButton();
        getThresholdStatsButton = new javax.swing.JButton();
        jLabel9 = new javax.swing.JLabel();
        roiPixelsTF = new javax.swing.JFormattedTextField();
        tollBarPane = new javax.swing.JPanel();
        imageToolbar = new javax.swing.JToolBar();
        roiRectnagularRB = new javax.swing.JRadioButton();
        roiPointRB = new javax.swing.JRadioButton();
        freehandPointRB = new javax.swing.JRadioButton();
        jSeparator1 = new javax.swing.JToolBar.Separator();
        zoomButton = new javax.swing.JButton();
        jSeparator3 = new javax.swing.JToolBar.Separator();
        flipHorizontallyButton = new javax.swing.JButton();
        jSeparator4 = new javax.swing.JToolBar.Separator();
        flipVerticalyButton = new javax.swing.JButton();
        jSeparator2 = new javax.swing.JToolBar.Separator();
        extractPixelButton = new javax.swing.JButton();
        jSeparator6 = new javax.swing.JToolBar.Separator();
        autoColorButton = new javax.swing.JButton();
        jSeparator5 = new javax.swing.JToolBar.Separator();
        imageResetButton = new javax.swing.JButton();
        jSeparator7 = new javax.swing.JToolBar.Separator();
        exportToImageJButton = new javax.swing.JButton();
        jSeparator8 = new javax.swing.JToolBar.Separator();
        settingsButton = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();

        setBackground(new java.awt.Color(0, 0, 0));
        setPreferredSize(new java.awt.Dimension(1000, 800));
        setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.LINE_AXIS));

        jSplitPane1.setBackground(new java.awt.Color(25, 25, 25));
        jSplitPane1.setDividerLocation(300);
        jSplitPane1.setContinuousLayout(true);
        jSplitPane1.setOneTouchExpandable(true);
        jSplitPane1.setOpaque(false);

        imageListPane.setBackground(new java.awt.Color(0, 0, 0));
        imageListPane.setLayout(new java.awt.BorderLayout());

        jScrollPane2.setBackground(new java.awt.Color(204, 204, 204));
        jScrollPane2.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Image List", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.ABOVE_TOP, new java.awt.Font("Lucida Grande", 1, 18), new java.awt.Color(255, 255, 255))); // NOI18N

        imageJList.setBackground(new java.awt.Color(0, 0, 0));
        imageJList.setForeground(new java.awt.Color(255, 255, 255));
        imageJList.setModel(generateDefaultListModel());
        imageJList.setCellRenderer(new CustomCellRenderer());
        imageJList.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                imageJListMousePressed(evt);
            }
        });
        imageJList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                imageJListValueChanged(evt);
            }
        });
        jScrollPane2.setViewportView(imageJList);

        imageListPane.add(jScrollPane2, java.awt.BorderLayout.CENTER);

        setup_pane.setBackground(new java.awt.Color(0, 0, 0));
        setup_pane.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Grande", 3, 14))); // NOI18N

        slice_label.setFont(new java.awt.Font("Lucida Grande", 1, 13)); // NOI18N
        slice_label.setForeground(new java.awt.Color(255, 255, 255));
        slice_label.setText("Slice Number");

        element_label.setFont(new java.awt.Font("Lucida Grande", 1, 13));
        element_label.setForeground(new java.awt.Color(255, 255, 255));
        element_label.setText("Element Number");

        slice_ftxt.setBackground(new java.awt.Color(0, 0, 0));
        slice_ftxt.setForeground(new java.awt.Color(255, 255, 255));
        slice_ftxt.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter(new java.text.DecimalFormat("###0"))));
        slice_ftxt.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        slice_ftxt.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        slice_ftxt.setInputVerifier(new SliceSelectionFieldVerifier());

        org.jdesktop.beansbinding.Binding binding = org.jdesktop.beansbinding.Bindings.createAutoBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, slice_slider, org.jdesktop.beansbinding.ELProperty.create("${value}"), slice_ftxt, org.jdesktop.beansbinding.BeanProperty.create("text"));
        bindingGroup.addBinding(binding);

        element_ftxt.setBackground(new java.awt.Color(0, 0, 0));
        element_ftxt.setForeground(new java.awt.Color(255, 255, 255));
        element_ftxt.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter(new java.text.DecimalFormat("###0"))));
        element_ftxt.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        element_ftxt.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        element_ftxt.setInputVerifier(new ElementSelectionFieldVerifier());

        binding = org.jdesktop.beansbinding.Bindings.createAutoBinding(org.jdesktop.beansbinding.AutoBinding.UpdateStrategy.READ_WRITE, element_slider, org.jdesktop.beansbinding.ELProperty.create("${value}"), element_ftxt, org.jdesktop.beansbinding.BeanProperty.create("text"));
        bindingGroup.addBinding(binding);

        slice_slider.setBackground(new java.awt.Color(0, 0, 0));
        slice_slider.setForeground(new java.awt.Color(255, 255, 0));
        slice_slider.setMaximum(getNSlices());
        slice_slider.setMinimum(1);
        slice_slider.setMinorTickSpacing(1);
        slice_slider.setValue(0);
        slice_slider.setOpaque(true);
        slice_slider.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                slice_sliderStateChanged(evt);
            }
        });

        element_slider.setBackground(new java.awt.Color(0, 0, 0));
        element_slider.setForeground(new java.awt.Color(255, 255, 0));
        element_slider.setMinorTickSpacing(1);
        element_slider.setValue(0);
        element_slider.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                element_sliderStateChanged(evt);
            }
        });

        sliceMaxLabel.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        sliceMaxLabel.setForeground(new java.awt.Color(255, 255, 255));

        elementMaxLabel.setFont(new java.awt.Font("Lucida Grande", 1, 14)); // NOI18N
        elementMaxLabel.setForeground(new java.awt.Color(255, 255, 255));

        org.jdesktop.layout.GroupLayout setup_paneLayout = new org.jdesktop.layout.GroupLayout(setup_pane);
        setup_pane.setLayout(setup_paneLayout);
        setup_paneLayout.setHorizontalGroup(
            setup_paneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(setup_paneLayout.createSequentialGroup()
                .add(20, 20, 20)
                .add(setup_paneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, slice_slider, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 241, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, element_slider, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 241, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, setup_paneLayout.createSequentialGroup()
                        .add(setup_paneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(element_label)
                            .add(slice_label))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(setup_paneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(slice_ftxt, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 44, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(element_ftxt, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 44, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(setup_paneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(elementMaxLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 63, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(sliceMaxLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 34, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))))
                .add(33, 33, 33))
        );

        setup_paneLayout.linkSize(new java.awt.Component[] {element_label, slice_label}, org.jdesktop.layout.GroupLayout.HORIZONTAL);

        setup_paneLayout.linkSize(new java.awt.Component[] {element_ftxt, slice_ftxt}, org.jdesktop.layout.GroupLayout.HORIZONTAL);

        setup_paneLayout.linkSize(new java.awt.Component[] {elementMaxLabel, sliceMaxLabel}, org.jdesktop.layout.GroupLayout.HORIZONTAL);

        setup_paneLayout.setVerticalGroup(
            setup_paneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(setup_paneLayout.createSequentialGroup()
                .add(setup_paneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.CENTER)
                    .add(slice_label)
                    .add(slice_ftxt, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(sliceMaxLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 17, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(slice_slider, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 22, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(18, 18, 18)
                .add(setup_paneLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(element_label)
                    .add(element_ftxt, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(elementMaxLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 15, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(element_slider, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 16, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        setup_paneLayout.linkSize(new java.awt.Component[] {elementMaxLabel, element_ftxt, sliceMaxLabel, slice_ftxt}, org.jdesktop.layout.GroupLayout.VERTICAL);

        imageListPane.add(setup_pane, java.awt.BorderLayout.SOUTH);

        jSplitPane1.setLeftComponent(imageListPane);

        imahgeAndSettingsScrollPamel.setBackground(new java.awt.Color(0, 0, 0));

        ImageAndCalibrationBar.setBackground(new java.awt.Color(0, 0, 0));
        ImageAndCalibrationBar.setMinimumSize(new java.awt.Dimension(590, 670));
        ImageAndCalibrationBar.setPreferredSize(new java.awt.Dimension(590, 650));
        ImageAndCalibrationBar.setLayout(new java.awt.BorderLayout());

        imagePane.setBackground(new java.awt.Color(0, 0, 0));
        imagePane.setBorder(null);
        imagePane.setOpaque(false);
        imagePane.setPreferredSize(new java.awt.Dimension(570, 555));
        imagePane.getCanvas().addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseMoved(java.awt.event.MouseEvent evt) {
                imagePaneMouseMoved(evt);
            }
        });
        ImageAndCalibrationBar.add(imagePane, java.awt.BorderLayout.PAGE_START);

        paddedCalibrationBar.setBackground(new java.awt.Color(0, 0, 0));
        paddedCalibrationBar.setLayout(new java.awt.GridBagLayout());

        calibrationBar.setBackground(new java.awt.Color(0, 0, 0));
        calibrationBar.setVisible(false);
        calibrationBar.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                calibrationBarPropertyChange(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.insets = new java.awt.Insets(0, 58, 0, 0);
        paddedCalibrationBar.add(calibrationBar, gridBagConstraints);

        ImageAndCalibrationBar.add(paddedCalibrationBar, java.awt.BorderLayout.SOUTH);

        toolpane.setBackground(new java.awt.Color(255, 255, 255));
        toolpane.setLayout(new javax.swing.BoxLayout(toolpane, javax.swing.BoxLayout.Y_AXIS));

        PixelInfoPane.setBackground(new java.awt.Color(0, 0, 0));
        PixelInfoPane.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1), "Pixel Info", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Grande", 0, 18), new java.awt.Color(255, 255, 255))); // NOI18N
        PixelInfoPane.setLayout(new java.awt.GridBagLayout());

        jLabel1.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel1.setForeground(new java.awt.Color(255, 255, 255));
        jLabel1.setText("X pos");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
        PixelInfoPane.add(jLabel1, gridBagConstraints);

        jLabel2.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel2.setForeground(new java.awt.Color(255, 255, 255));
        jLabel2.setText("Y pos");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
        PixelInfoPane.add(jLabel2, gridBagConstraints);

        jLabel3.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel3.setForeground(new java.awt.Color(255, 255, 255));
        jLabel3.setText("Value");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 6);
        PixelInfoPane.add(jLabel3, gridBagConstraints);

        textField1.setBackground(new java.awt.Color(51, 51, 51));
        textField1.setEditable(false);
        textField1.setForeground(new java.awt.Color(255, 255, 255));
        textField1.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        textField1.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        PixelInfoPane.add(textField1, gridBagConstraints);

        textField2.setBackground(new java.awt.Color(51, 51, 51));
        textField2.setEditable(false);
        textField2.setForeground(new java.awt.Color(255, 255, 255));
        textField2.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        textField2.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        PixelInfoPane.add(textField2, gridBagConstraints);

        textField3.setBackground(new java.awt.Color(51, 51, 51));
        textField3.setEditable(false);
        textField3.setForeground(new java.awt.Color(255, 255, 255));
        textField3.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        textField3.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        textField3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textField3ActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        PixelInfoPane.add(textField3, gridBagConstraints);

        toolpane.add(PixelInfoPane);

        statPane.setBackground(new java.awt.Color(0, 0, 0));
        statPane.setBorder(javax.swing.BorderFactory.createTitledBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1), "Image Statistics", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Lucida Grande", 0, 18), new java.awt.Color(255, 255, 255))); // NOI18N
        statPane.setLayout(new java.awt.GridBagLayout());

        jLabel4.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel4.setForeground(new java.awt.Color(255, 255, 255));
        jLabel4.setText("Mean");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
        statPane.add(jLabel4, gridBagConstraints);

        jLabel5.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel5.setForeground(new java.awt.Color(255, 255, 255));
        jLabel5.setText("Max");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
        statPane.add(jLabel5, gridBagConstraints);

        jLabel6.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel6.setForeground(new java.awt.Color(255, 255, 255));
        jLabel6.setText("Min");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 6);
        statPane.add(jLabel6, gridBagConstraints);

        jLabel7.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel7.setForeground(new java.awt.Color(255, 255, 255));
        jLabel7.setText("Sdev");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 6);
        statPane.add(jLabel7, gridBagConstraints);

        jLabel8.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel8.setForeground(new java.awt.Color(255, 255, 255));
        jLabel8.setText("RMS");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 6);
        statPane.add(jLabel8, gridBagConstraints);

        getStatsButton.setText("Get statistics");
        getStatsButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nGenerate statistics for selected ROI.<br>\nIf no ROI is specified, all image<br>\npixels are analyzed.\n\n\n</font></p><html>\n"); // NOI18N
        getStatsButton.setIconTextGap(40);
        getStatsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getStatsButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        statPane.add(getStatsButton, gridBagConstraints);

        roiMeanTF.setBackground(new java.awt.Color(51, 51, 51));
        roiMeanTF.setEditable(false);
        roiMeanTF.setForeground(new java.awt.Color(255, 255, 255));
        roiMeanTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        roiMeanTF.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nMean value for pixels in the ROI.<br>\nIf no ROI is specified, all image<br>\npixels are analyzed.\n\n\n</font></p><html>\n"); // NOI18N
        roiMeanTF.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        statPane.add(roiMeanTF, gridBagConstraints);

        roiMaxTF.setBackground(new java.awt.Color(51, 51, 51));
        roiMaxTF.setEditable(false);
        roiMaxTF.setForeground(new java.awt.Color(255, 255, 255));
        roiMaxTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        roiMaxTF.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nMaximum  value for pixels in the ROI.<br>\nIf no ROI is specified, all image<br>\npixels are analyzed.\n\n\n</font></p><html>\n"); // NOI18N
        roiMaxTF.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        statPane.add(roiMaxTF, gridBagConstraints);

        roiMinTF.setBackground(new java.awt.Color(51, 51, 51));
        roiMinTF.setEditable(false);
        roiMinTF.setForeground(new java.awt.Color(255, 255, 255));
        roiMinTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        roiMinTF.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nMinimum  value for pixels in the ROI.<br>\nIf no ROI is specified, all image<br>\npixels are analyzed.\n\n\n</font></p><html>\n"); // NOI18N
        roiMinTF.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        statPane.add(roiMinTF, gridBagConstraints);

        roiSdevTF.setBackground(new java.awt.Color(51, 51, 51));
        roiSdevTF.setEditable(false);
        roiSdevTF.setForeground(new java.awt.Color(255, 255, 255));
        roiSdevTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        roiSdevTF.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nStandard deviation for pixels in the ROI.<br>\nIf no ROI is specified, all image<br>\npixels are analyzed.\n\n\n</font></p><html>\n"); // NOI18N
        roiSdevTF.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        statPane.add(roiSdevTF, gridBagConstraints);

        roiRmsTF.setBackground(new java.awt.Color(51, 51, 51));
        roiRmsTF.setEditable(false);
        roiRmsTF.setForeground(new java.awt.Color(255, 255, 255));
        roiRmsTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        roiRmsTF.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nRoot mean square for pixels in the ROI.<br>\nIf no ROI is specified, all image<br>\npixels are analyzed.\n\n\n</font></p><html>"); // NOI18N
        roiRmsTF.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        statPane.add(roiRmsTF, gridBagConstraints);

        saveStatsButton.setText("Save statistics");
        saveStatsButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nSave statisitics to a file.<br>\n\n\n</font></p><html>\n"); // NOI18N
        saveStatsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveStatsButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        statPane.add(saveStatsButton, gridBagConstraints);

        getThresholdStatsButton.setText("Get threshold stats");
        getThresholdStatsButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nGenerate statistics for selected ROI<br>\npixels that satisfy  threshold values<br>\nspecified by user.<br>\nIf no ROI is specified, all image<br>\npixels are analyzed.\n\n\n</font></p><html>\n"); // NOI18N
        getThresholdStatsButton.setIconTextGap(40);
        getThresholdStatsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getThresholdStatsButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        statPane.add(getThresholdStatsButton, gridBagConstraints);

        jLabel9.setFont(new java.awt.Font("Lucida Grande", 0, 14));
        jLabel9.setForeground(new java.awt.Color(255, 255, 255));
        jLabel9.setText("Pixels");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 6);
        statPane.add(jLabel9, gridBagConstraints);

        roiPixelsTF.setBackground(new java.awt.Color(51, 51, 51));
        roiPixelsTF.setEditable(false);
        roiPixelsTF.setForeground(new java.awt.Color(255, 255, 255));
        roiPixelsTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        roiPixelsTF.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nNumber of pixels from ROI that were<br>\nused to generate statistics.<br>\nIf no ROI is specified, all image<br>\npixels are analyzed.\n\n</font></p><html>"); // NOI18N
        roiPixelsTF.setFont(new java.awt.Font("Lucida Grande", 1, 14));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 3.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 0, 3, 0);
        statPane.add(roiPixelsTF, gridBagConstraints);

        toolpane.add(statPane);

        tollBarPane.setBackground(new java.awt.Color(255, 255, 255));
        tollBarPane.setLayout(new javax.swing.BoxLayout(tollBarPane, javax.swing.BoxLayout.LINE_AXIS));

        imageToolbar.setBackground(new java.awt.Color(255, 255, 255));
        imageToolbar.setFloatable(false);
        imageToolbar.setForeground(new java.awt.Color(255, 255, 255));
        imageToolbar.setOrientation(1);
        imageToolbar.setRollover(true);
        imageToolbar.setMaximumSize(new java.awt.Dimension(35, 33259));
        imageToolbar.setMinimumSize(new java.awt.Dimension(30, 488));
        imageToolbar.setPreferredSize(new java.awt.Dimension(30, 567));

        roiType.add(roiRectnagularRB);
        roiRectnagularRB.setSelected(true);
        roiRectnagularRB.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nRectangular ROI\n</html>\n"); // NOI18N
        roiRectnagularRB.setBorderPainted(true);
        roiRectnagularRB.setFocusable(false);
        roiRectnagularRB.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        roiRectnagularRB.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/rectangleROI.png"))); // NOI18N
        roiRectnagularRB.setRolloverEnabled(true);
        roiRectnagularRB.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/rectangleROIMouseOver.png"))); // NOI18N
        roiRectnagularRB.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/rectangleROIMouseOver.png"))); // NOI18N
        roiRectnagularRB.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        roiRectnagularRB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                roiRectnagularRBActionPerformed(evt);
            }
        });
        imageToolbar.add(roiRectnagularRB);

        roiType.add(roiPointRB);
        roiPointRB.setFont(new java.awt.Font("Lucida Grande", 0, 11)); // NOI18N
        roiPointRB.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nPoint ROI\n</html>\n"); // NOI18N
        roiPointRB.setBorderPainted(true);
        roiPointRB.setFocusable(false);
        roiPointRB.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        roiPointRB.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        roiPointRB.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/pointRoi.png"))); // NOI18N
        roiPointRB.setMargin(new java.awt.Insets(0, 0, 0, 0));
        roiPointRB.setMaximumSize(new java.awt.Dimension(32, 32));
        roiPointRB.setMinimumSize(new java.awt.Dimension(32, 32));
        roiPointRB.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/pointRoiMouseOver.png"))); // NOI18N
        roiPointRB.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/pointRoiMouseOver.png"))); // NOI18N
        roiPointRB.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        roiPointRB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                roiPointRBActionPerformed(evt);
            }
        });
        imageToolbar.add(roiPointRB);

        roiType.add(freehandPointRB);
        freehandPointRB.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nPolygon ROI\n</html>\n"); // NOI18N
        freehandPointRB.setBorderPainted(true);
        freehandPointRB.setFocusable(false);
        freehandPointRB.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        freehandPointRB.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/polygonRoi.png"))); // NOI18N
        freehandPointRB.setRolloverEnabled(true);
        freehandPointRB.setRolloverSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/polygonRoiMouseOver.png"))); // NOI18N
        freehandPointRB.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/polygonRoiMouseOver.png"))); // NOI18N
        freehandPointRB.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        freehandPointRB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                freehandPointRBActionPerformed(evt);
            }
        });
        imageToolbar.add(freehandPointRB);

        jSeparator1.setBackground(new java.awt.Color(255, 255, 255));
        jSeparator1.setOpaque(true);
        imageToolbar.add(jSeparator1);

        zoomButton.setBackground(new java.awt.Color(255, 255, 255));
        zoomButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/zoom_32x32.png"))); // NOI18N
        zoomButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nZoom in (for rectangular ROI only)\n</html>\n\n\n"); // NOI18N
        zoomButton.setFocusable(false);
        zoomButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        zoomButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        zoomButton.setMaximumSize(new java.awt.Dimension(32, 32));
        zoomButton.setMinimumSize(new java.awt.Dimension(32, 32));
        zoomButton.setOpaque(true);
        zoomButton.setPreferredSize(new java.awt.Dimension(32, 32));
        zoomButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        zoomButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                zoomButtonActionPerformed(evt);
            }
        });
        imageToolbar.add(zoomButton);

        jSeparator3.setBackground(new java.awt.Color(255, 255, 255));
        jSeparator3.setOpaque(true);
        imageToolbar.add(jSeparator3);

        flipHorizontallyButton.setBackground(new java.awt.Color(255, 255, 255));
        flipHorizontallyButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/flipH.png"))); // NOI18N
        flipHorizontallyButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nFlip image horizontally.\n</html>\n\n\n"); // NOI18N
        flipHorizontallyButton.setFocusable(false);
        flipHorizontallyButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        flipHorizontallyButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        flipHorizontallyButton.setOpaque(true);
        flipHorizontallyButton.setPreferredSize(new java.awt.Dimension(32, 32));
        flipHorizontallyButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        flipHorizontallyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                flipHorizontallyButtonActionPerformed(evt);
            }
        });
        imageToolbar.add(flipHorizontallyButton);

        jSeparator4.setBackground(new java.awt.Color(255, 255, 255));
        jSeparator4.setOpaque(true);
        imageToolbar.add(jSeparator4);

        flipVerticalyButton.setBackground(new java.awt.Color(255, 255, 255));
        flipVerticalyButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/flipV.png"))); // NOI18N
        flipVerticalyButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nFlip image vertically.\n</html>\n\n\n"); // NOI18N
        flipVerticalyButton.setFocusable(false);
        flipVerticalyButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        flipVerticalyButton.setIconTextGap(0);
        flipVerticalyButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        flipVerticalyButton.setMinimumSize(new java.awt.Dimension(32, 32));
        flipVerticalyButton.setPreferredSize(new java.awt.Dimension(32, 32));
        flipVerticalyButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        flipVerticalyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                flipVerticalyButtonActionPerformed(evt);
            }
        });
        imageToolbar.add(flipVerticalyButton);

        jSeparator2.setBackground(new java.awt.Color(255, 255, 255));
        jSeparator2.setOpaque(true);
        imageToolbar.add(jSeparator2);

        extractPixelButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/extractPixel.png"))); // NOI18N
        extractPixelButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\nExtract image pixel. <br>\n</html>\n\n\n"); // NOI18N
        extractPixelButton.setFocusable(false);
        extractPixelButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        extractPixelButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        extractPixelButton.setPreferredSize(new java.awt.Dimension(32, 32));
        extractPixelButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        extractPixelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                extractPixelButtonActionPerformed(evt);
            }
        });
        imageToolbar.add(extractPixelButton);

        jSeparator6.setBackground(new java.awt.Color(255, 255, 255));
        jSeparator6.setOpaque(true);
        imageToolbar.add(jSeparator6);

        autoColorButton.setBackground(new java.awt.Color(51, 51, 51));
        autoColorButton.setFont(new java.awt.Font("Lucida Grande", 0, 10)); // NOI18N
        autoColorButton.setForeground(new java.awt.Color(204, 0, 0));
        autoColorButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/contrast32x32.png"))); // NOI18N
        autoColorButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nAutoset image greyscale. <br>\nGreyscale bounds are computed<br>\nfrom the minimum and maximum<br> \npixel values in the entire image stack.\n\n</font></p><html>\n\n\n\n"); // NOI18N
        autoColorButton.setFocusable(false);
        autoColorButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        autoColorButton.setPreferredSize(new java.awt.Dimension(32, 32));
        autoColorButton.setRolloverEnabled(true);
        autoColorButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/contrast32x32up.jpg"))); // NOI18N
        autoColorButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        autoColorButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                autoColorButtonActionPerformed(evt);
            }
        });
        imageToolbar.add(autoColorButton);

        jSeparator5.setBackground(new java.awt.Color(255, 255, 255));
        jSeparator5.setOpaque(true);
        imageToolbar.add(jSeparator5);

        imageResetButton.setBackground(new java.awt.Color(51, 51, 51));
        imageResetButton.setFont(new java.awt.Font("Lucida Grande", 0, 10)); // NOI18N
        imageResetButton.setForeground(new java.awt.Color(204, 0, 0));
        imageResetButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/Reset.png"))); // NOI18N
        imageResetButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nDisplay original image.<br>\n\n</font></p><html>\n\n"); // NOI18N
        imageResetButton.setFocusable(false);
        imageResetButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        imageResetButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        imageResetButton.setPreferredSize(new java.awt.Dimension(32, 32));
        imageResetButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        imageResetButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                imageResetButtonActionPerformed(evt);
            }
        });
        imageToolbar.add(imageResetButton);

        jSeparator7.setBackground(new java.awt.Color(255, 255, 255));
        jSeparator7.setOpaque(true);
        imageToolbar.add(jSeparator7);

        exportToImageJButton.setBackground(new java.awt.Color(51, 51, 51));
        exportToImageJButton.setFont(new java.awt.Font("Lucida Grande", 0, 10));
        exportToImageJButton.setForeground(new java.awt.Color(204, 0, 0));
        exportToImageJButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/imageJ_32x32.jpeg"))); // NOI18N
        exportToImageJButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nView current image stack in ImageJ<br>\n\n</font></p><html>\n\n"); // NOI18N
        exportToImageJButton.setFocusable(false);
        exportToImageJButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        exportToImageJButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        exportToImageJButton.setPreferredSize(new java.awt.Dimension(32, 32));
        exportToImageJButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/imageJ_MOUSEOVER_32x32.jpg"))); // NOI18N
        exportToImageJButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        exportToImageJButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exportToImageJButtonActionPerformed(evt);
            }
        });
        imageToolbar.add(exportToImageJButton);

        jSeparator8.setBackground(new java.awt.Color(255, 255, 255));
        jSeparator8.setOpaque(true);
        imageToolbar.add(jSeparator8);

        settingsButton.setBackground(new java.awt.Color(51, 51, 51));
        settingsButton.setFont(new java.awt.Font("Lucida Grande", 0, 10));
        settingsButton.setForeground(new java.awt.Color(204, 0, 0));
        settingsButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/settings32x32.png"))); // NOI18N
        settingsButton.setToolTipText("<html><p style=\"margin: 6px;\"><font size=\"4\">\n\nEdit Image Viewer Settings\n\n</font></p><html>\n\n"); // NOI18N
        settingsButton.setFocusable(false);
        settingsButton.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        settingsButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        settingsButton.setPreferredSize(new java.awt.Dimension(32, 32));
        settingsButton.setRolloverIcon(new javax.swing.ImageIcon(getClass().getResource("/bayes/resources/settings32x32MouseOver.jpg"))); // NOI18N
        settingsButton.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        settingsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                settingsButtonActionPerformed(evt);
            }
        });
        imageToolbar.add(settingsButton);

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 27, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 0, Short.MAX_VALUE)
        );

        imageToolbar.add(jPanel1);

        tollBarPane.add(imageToolbar);

        org.jdesktop.layout.GroupLayout imahgeAndSettingsScrollPamelLayout = new org.jdesktop.layout.GroupLayout(imahgeAndSettingsScrollPamel);
        imahgeAndSettingsScrollPamel.setLayout(imahgeAndSettingsScrollPamelLayout);
        imahgeAndSettingsScrollPamelLayout.setHorizontalGroup(
            imahgeAndSettingsScrollPamelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(imahgeAndSettingsScrollPamelLayout.createSequentialGroup()
                .add(603, 603, 603)
                .add(tollBarPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 38, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(553, Short.MAX_VALUE))
            .add(imahgeAndSettingsScrollPamelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(imahgeAndSettingsScrollPamelLayout.createSequentialGroup()
                    .add(10, 10, 10)
                    .add(ImageAndCalibrationBar, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 582, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(602, Short.MAX_VALUE)))
            .add(imahgeAndSettingsScrollPamelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(imahgeAndSettingsScrollPamelLayout.createSequentialGroup()
                    .add(692, 692, 692)
                    .add(toolpane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 231, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(271, Short.MAX_VALUE)))
        );
        imahgeAndSettingsScrollPamelLayout.setVerticalGroup(
            imahgeAndSettingsScrollPamelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(imahgeAndSettingsScrollPamelLayout.createSequentialGroup()
                .addContainerGap()
                .add(tollBarPane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 440, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(193, Short.MAX_VALUE))
            .add(imahgeAndSettingsScrollPamelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(imahgeAndSettingsScrollPamelLayout.createSequentialGroup()
                    .add(10, 10, 10)
                    .add(ImageAndCalibrationBar, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 622, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(21, Short.MAX_VALUE)))
            .add(imahgeAndSettingsScrollPamelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                .add(imahgeAndSettingsScrollPamelLayout.createSequentialGroup()
                    .add(10, 10, 10)
                    .add(toolpane, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .addContainerGap(165, Short.MAX_VALUE)))
        );

        imageScrollPanel.setViewportView(imahgeAndSettingsScrollPamel);

        jSplitPane1.setRightComponent(imageScrollPanel);

        add(jSplitPane1);

        bindingGroup.bind();
    }// </editor-fold>//GEN-END:initComponents

private void calibrationBarPropertyChange (java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_calibrationBarPropertyChange
   if (this.isIgnoreEvents() == true) {return;}
   if (evt.getPropertyName().equalsIgnoreCase(JCalibrationBar.CHANGE_CONTRAST) == false){return;}
   double min    =   getCalibrationBar().getMinLevel();
   double max    =   getCalibrationBar().getMaxLevel();
   getImagePane().setMinColorVal(min);
   getImagePane().setMaxColorVal(max);
   boolean keepImageScale   = true;
   drawCurrentImage( keepImageScale);
}//GEN-LAST:event_calibrationBarPropertyChange
private void element_sliderStateChanged (javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_element_sliderStateChanged
    if (isIgnoreEvents () == true) { return;}

    updateImage ();
}//GEN-LAST:event_element_sliderStateChanged
private void slice_sliderStateChanged (javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_slice_sliderStateChanged
    if (isIgnoreEvents () == true) { return;}

    updateImage ();
}//GEN-LAST:event_slice_sliderStateChanged
private void imageJListValueChanged (javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_imageJListValueChanged
    if(  isIgnoreEvents () ==true)       { return;}
    if (evt.getValueIsAdjusting () )     { return;}

    File file      = ( File)getImageJList ().getSelectedValue ();

    try {
        loadImageFile (file);
        getImageJList ().repaint();
    }catch(Exception exp){
        exp.printStackTrace();
        DisplayText.popupErrorMessage("Error while loading "+ file.getPath ()+".");
    }
}//GEN-LAST:event_imageJListValueChanged
private void imageJListMousePressed (java.awt.event.MouseEvent evt) {//GEN-FIRST:event_imageJListMousePressed
    if ( imageJList.getValueIsAdjusting() == false){
        if(SwingUtilities.isRightMouseButton (evt) == true )  {
        //if (isSingleSelectionMode()){
            if(this.getSelectedFile() == null){return;}
            boolean selectedMultiple            = (imageJList.getSelectedIndices().length > 1);
            boolean includeSingleItemOtpions    = !selectedMultiple;
            
            JPopupMenu popup        = new ImageViewerPopupMenu(includeSingleItemOtpions);
            popup.show (evt.getComponent (), evt.getX (), evt.getY ());
        //}
        
     }
    }

}//GEN-LAST:event_imageJListMousePressed
private void textField3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textField3ActionPerformed
    // TODO add your handling code here:
}//GEN-LAST:event_textField3ActionPerformed
private void getStatsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getStatsButtonActionPerformed
     getRoiStatistics (null, null);
}//GEN-LAST:event_getStatsButtonActionPerformed
private void saveStatsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveStatsButtonActionPerformed
    writeRoiFileFromGui();
}//GEN-LAST:event_saveStatsButtonActionPerformed
private void getThresholdStatsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getThresholdStatsButtonActionPerformed
  JPixelThreshold statDialog = JPixelThreshold.showDialog( );
  if (statDialog.isProceed()){
    Float lowerThreshold        =   statDialog.getLowerThreshold();
    Float upperThreshold        =   statDialog.getUpperThreshold();
    getRoiStatistics (lowerThreshold, upperThreshold  );

  }

}//GEN-LAST:event_getThresholdStatsButtonActionPerformed
private void extractPixelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_extractPixelButtonActionPerformed
    extractPixels();
}//GEN-LAST:event_extractPixelButtonActionPerformed
private void autoColorButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_autoColorButtonActionPerformed
    autoscaleColorScaleForStack();
}//GEN-LAST:event_autoColorButtonActionPerformed
private void imageResetButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_imageResetButtonActionPerformed
    getImagePane().unZoomImage();
    updateImage();
}//GEN-LAST:event_imageResetButtonActionPerformed
private void flipHorizontallyButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_flipHorizontallyButtonActionPerformed
    flipHorizontallyAllImages();
}//GEN-LAST:event_flipHorizontallyButtonActionPerformed
private void flipVerticalyButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_flipVerticalyButtonActionPerformed
    flipVerticallyAllImages();
}//GEN-LAST:event_flipVerticalyButtonActionPerformed
private void zoomButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_zoomButtonActionPerformed
   getImagePane().zoomImageFromRectangleRoi();
   updateImage();
}//GEN-LAST:event_zoomButtonActionPerformed
private void freehandPointRBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_freehandPointRBActionPerformed
     getImagePane().setTOOL_ID(Roi.POLYGON);
     getImagePane().killRoiWithoutSaving();
}//GEN-LAST:event_freehandPointRBActionPerformed
private void roiPointRBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_roiPointRBActionPerformed
     getImagePane().setTOOL_ID(Roi.POINT);
     getImagePane().killRoiWithoutSaving();
}//GEN-LAST:event_roiPointRBActionPerformed
private void roiRectnagularRBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_roiRectnagularRBActionPerformed
    getImagePane().setTOOL_ID(Roi.RECTANGLE);
    getImagePane().killRoiWithoutSaving();
}//GEN-LAST:event_roiRectnagularRBActionPerformed
private void exportToImageJButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exportToImageJButtonActionPerformed
 exportHyperStackToImageJ();
}//GEN-LAST:event_exportToImageJButtonActionPerformed

private void settingsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_settingsButtonActionPerformed
   JPreferences.displayImagePreferences();
}//GEN-LAST:event_settingsButtonActionPerformed
public void  imagePaneMouseMoved(java.awt.event.MouseEvent evt) {
    String text = null;
    int    pix ;
    float  pixValue =   getImagePane().getPixelValue();


    pix = getImagePane().getPixelX() ;
    if ( pix    <   0){ text    =   "";}
    else {              text  = pix + " ("+ evt.getX()+ ")"; }
    getTextField1().setText(text);

    pix = getImagePane().getPixelY() ;
    if ( pix    <   0){ text    =   "";}
    else {              text    =  pix + " ("+ evt.getY()+ ")"; }
    getTextField2().setText(text);

    if ( pix    <   0){ text    =   "";}

    else {   
            String format         = "%1."+ImageViewerPreferences.getImagePixelValuePresision() + "f";
        String valStr           = String.format( format ,  pixValue);
        text                    = valStr;
    }

    getTextField3().setText(text);

    pix = getImagePane().getPixelY() ;

    

    
}

    @Override
    public void propertyChange ( java.beans.PropertyChangeEvent evt ) {
   
    }
    
    
    public static void reset(){
        if (instance == null) {return;}
        instance.resetImageSettings();
        instance.closeImageJ();
        Window instwind  = SwingUtilities.getWindowAncestor(instance);
        Window toolbartwind  = SwingUtilities.getWindowAncestor(instance.imageToolbar);
        if (toolbartwind != instwind ){toolbartwind.dispose(); }
        instance = null;
        
}
    public  void resetImageSettings(){
       getImagePane().reset();
}
    public void resetSlidersPane(){
        getSliceSlider ().setValue(1);
        getSliceMaxLabel ().setText("1");
        getElementSlider ().setValue(1);
        getElementMaxLabel ().setText("1");
    }


    public void updateSettingsFromImage(){
        getSliceSlider().setMaximum(getNSlices());
        getElementSlider().setMaximum(getNElements());
        getSliceSlider().setMinimum(1);
        getElementSlider().setMinimum(1);

        getElementMaxLabel ().setText("of "+getNElements());
        getSliceMaxLabel ().setText("of "+getNSlices());

        if (getNSlices() == 1){
             getSliceSlider().setEnabled(false);
        }
        else {
             getSliceSlider().setEnabled(true);
        }
        if (getNElements() == 1){
              getElementSlider().setEnabled(false);
        }
        else {
             getElementSlider().setEnabled(true);

        }
        
    }
  
 

    public void loadDefaultFile()  {
        updateImageList();

    }
    public void loadDefaultImageIfNeeded()  {
       if (getImageJList() .isSelectionEmpty() == true){

            File realLoadImageFile = DirectoryManager.getRealImageFile();
            if (isValidImageFile(realLoadImageFile) == false) {return;}

            getImageJList().setSelectedValue(realLoadImageFile, true);


       }

    }
    public void loadAndSetImageFile(File imageFile )  {
        if (imageFile == null){return;}
        resetImageSettings();
        setIgnoreEvents(true);
            DefaultListModel list    = generateDefaultListModel();
            getImageJList ().setModel(list   );

         setIgnoreEvents(false);

         if ( list   .contains(imageFile)){
               getImageJList().setSelectedValue(imageFile,true);
         }

}

    private void loadImageFile(File imageFile )  {
       if (imageFile == null){return;}
       File descriptorFile   =       DirectoryManager.getIfhFileForImage(imageFile);
       setIgnoreEvents(true);
      try {
            
            if (descriptorFile.exists() == false){
                String error = descriptorFile.getPath() + " doesn't exist. Exiting... ";
                DisplayText.popupErrorMessage(error);
                resetImageSettings();
            }
             if (imageFile.exists() == false){
                String error = imageFile.getPath() + " doesn't exist. Exiting... ";
                DisplayText.popupErrorMessage(error);
                resetImageSettings();
            }
            //load and set image descriptor
            ImageDescriptor id   = ImageIO.loadFromDisk(descriptorFile);

             boolean reset = !ImageHelper.areEquivalentImages(id, getImageDescriptor());
             if (reset  == true){resetImageSettings();}

            setImageDescriptor(id);
          //  imageInfoPane.update(id);
           
            // load and set binary image
            //ImageIO  imageInfo      =    ImageIO.readImage(imageFile, id);
            ImageIO  imageInfo      =    ImageIO.readImage(imageFile, id);
            getImagePane().setAllImages( imageInfo.getImgArray());
            
            
            boolean resetConstrast      =   reset ||ImageViewerPreferences.isAutoContrastNewImage();
            if (resetConstrast ){
                getImagePane().setMinColorVal(imageInfo.getMinValue());
                getImagePane().setMaxColorVal(imageInfo.getMaxValue());
                getCalibrationBar ().update(imageInfo.getMinValue(), imageInfo.getMaxValue());
            }



            // set new ascpect ratio
            float aspectRatio = ImageDescriptor.computeImageAspectRatio(id);
            getImagePane().setAspectRatio(aspectRatio);

            firePropertyChange( IMAGE_HAS_BEEN_LOADED , null,id);

            // set new element and slice slider limits
            updateSettingsFromImage();

           
          
        } catch (FileNotFoundException ex) {
             ex.printStackTrace();
            return;
        } catch (IOException ex) {
             ex.printStackTrace();
             return;
        }
        finally{
            // update and redraw image
            updateImage();
            setIgnoreEvents(false);
            Runtime.getRuntime().gc();

        }
        
}
    /*
    public void resetConstrast(double ){
        getImagePane().setMinColorVal(WIDTH);
    }
     *
     */


    public void extractPixels(){
        PixelExtractor pe =  new PixelExtractor () ;
        try{
            pe.extractPixel();
        }
        finally{
            Runtime.getRuntime().gc();
        }
    }
    public void loadPixelsFromRoi(){
        PixelHistogrammer  ph =  new PixelHistogrammer  () ;
        try{
            ph.loadPixels();
        }
        finally{
            Runtime.getRuntime().gc();
        }
    }


   

     public void             viewPixelsForHistogram(){
        float [] pixels        =   getPixelsForHistogram();
        StringBuilder sb       =   getPixelsForHistogramAsText(pixels);
        Viewer.display(sb.toString(),"Image Pixels");
    }
     public void             histogramPixels(){
        if (this.isImageSelected()  == false){return;}
        float [] pixels        =   getPixelsForHistogram();
        double []data          =   new double [pixels.length];
        for (int i = 0; i < data.length; i++) {
              data[i] = pixels [i];

         }
        String serName             = getSelectedFile().getName();
        JHistogram.showHistogram( data  , serName , "Pixel Histogram", "Pixel Value", "Counts");
    }
    public StringBuilder    getPixelsForHistogramAsText(float [] pixles){
        StringBuilder sb        =   new StringBuilder();
        String delimiter        =   "  ";

         for (int curPixel = 0; curPixel < pixles.length; curPixel++) {
                float f = pixles[curPixel];
                if(Float.compare(f, Float.NaN) == 0){continue;}
                sb.append(curPixel);
                sb.append(delimiter);
                sb.append( f);
                sb.append("\n");

         }

         return sb;

    }
    private float []        getPixelsForHistogram(){
        int numSlices          =    getNSlices();
        int curSlice           =    getCurrentSlice() -1;
        int curElement         =    getCurrentElement()-1;
        int curImage           =    curSlice + curElement*numSlices;
        float [] pixles        =    getImagePane(). getRoiPixelsForImageAt(curImage);
     
        return pixles;

    }

    public void getRoiStatistics ( Float lowerthreshold, Float upperthreshold) {
        if (getSelectedFile() == null){return;}

        int curElement      =   getElement ();
        int curSlice        =   getSlice ();
        Statistics stats    =   getImagePane().getRoiStatsForImageAt(curSlice, curElement, lowerthreshold,upperthreshold);

        displayStatistics(stats);
    }
    public void displayStatistics ( Statistics stats ) {
        String f                  = "%1.4e";
        String text;
        StringBuilder sb          = new StringBuilder();

        //mean
        text            = String.format(f, stats.getMean());
        getStatMeanTextField().setText(text);

        //min
        text            = String.format(f, stats.getMin());
        getStatMinTextField().setText(text);

        //max
        text            = String.format(f, stats.getMax());
        getStatMaxTextField().setText( text);

        //sdev
        text            = String.format(f, stats.getSdev());
        getStatSdevTextField().setText(text);

        //rms
        text            = String.format(f, stats.getRootMeanSqare());
        getGuiStatRmsTextField().setText(text);

        //npixels
        text            = String.format("%d", stats.getNumelements());
        getGuiStatNumPixelsTextField ().setText(text);

       // File imageDir                   =   DirectoryManager.getImageDir();
       // File file                       =   new File (imageDir, "Roi");
       // writeRoiFile(file, stats);

    }
    public void writeRoiFileFromGui(){
        String meanStr              =   getGUIStatMean();
        String minStr               =   getGUIStatMin();
        String maxStr               =   getGUIStatMax();
        String sdevStr              =   getGUIStatSdev();
        String rmsStr               =   getGUIStatRms();
        String pixStr               =   getGUIStatPixels();

        boolean isStatComplete      =   false;
        if (    meanStr.isEmpty() || minStr.isEmpty() || maxStr.isEmpty()
            ||  sdevStr.isEmpty() || rmsStr.isEmpty() || pixStr.isEmpty())
        {
            isStatComplete      =   false;
        }
        else{
            isStatComplete      =   true;
        }

        if (isStatComplete == false){
            String error            = String.format(
                    "No ROI statistics is available.\n"
                  + "You should generate statistics\n"
                  + "prior to saving it to a text file.","");
            DisplayText.popupMessage(error);
            return;
        }


        JFileChooser fc                 =   new JFileChooser();
        fc.setDialogType(JFileChooser.SAVE_DIALOG);
        fc.setCurrentDirectory(getRoiDir());
        // fc.setFileSelectionMode(javax.swing.JFileChooser.FILES_ONLY);
        fc.setMultiSelectionEnabled(false);
        // fc.setApproveButtonText("Save");
        fc.setDialogTitle("Save Image Statistics");


         int returnVal              = fc.showSaveDialog(null);

         if (returnVal == JFileChooser.APPROVE_OPTION) {
            File  file                  =   fc.getSelectedFile ();
            DirectoryManager.startDir   = fc.getCurrentDirectory();
            StringBuilder buffer = new StringBuilder();
            String sp                   =   "\t";
            buffer.append( "Min     "+ sp + " = "+ sp + minStr  + "\n");
            buffer.append( "Mean    "+ sp + " = "+ sp + meanStr + "\n");
            buffer.append( "Max     "+ sp + " = "+ sp + maxStr + "\n");
            buffer.append( "SDev    "+ sp + " = "+ sp + sdevStr + "\n");
            buffer.append( "RMS     "+ sp + " = "+ sp + rmsStr + "\n");
            buffer.append( "Pixels  "+ sp + " = "+ sp + pixStr + "\n");

            IO.writeFileFromString( buffer.toString(), file );
            setRoiDir(file );
        } else {
            return;
        }


      
    }

    public String getInfo() {
         String info     = "Image Info";

         if (getSelectedFile() == null){
                    info = "No image is selected";
         }
         else{
             File file  = getSelectedIFHFile();
             info       =   IO.readFileToString(file);
         }
       
        return info;
    }


    
    public void autoscaleColorScaleForStack(){
            double [] stat      =   getImagePane().computeImageStackStatistics();
            double  min         =   stat[0];
            double  max         =   stat[1];
            getImagePane().setMinColorVal(min);
            getImagePane().setMaxColorVal(max);
            getCalibrationBar ().update(min, max);
            updateImage();
    }
    public void autoscaleColorScaleForCurrentImage(){
            int curElement      = getElement ();
            int curSlice        = getSlice ();
            double [] stat      =   getImagePane().computeImageStatistics(curSlice, curElement);
            double  min         =   stat[0];
            double  max         =   stat[1];
            getImagePane().setMinColorVal(min);
            getImagePane().setMaxColorVal(max);
            getCalibrationBar ().update(min, max);
            updateImage();
    }



    void writeAsciiFile(){
       List <float[][]> allImages   =   this.imagePane.getAllImages();
       File dir                     =   DirectoryManager.getExperimentDir();
       File imageFile               =   new File(dir,"asciiImage");
       StringBuilder sb             =   new StringBuilder();

       int row                      =   this.getImageDescriptor().getNumberOfRows();
       int col                      =   this.getImageDescriptor().getNumberOfColumns();
        for (float[][] curImage : allImages) {
            for (int r = 0; r < row; r++) {
                 for (int c = 0; c < col; c++) {
                 //    System.out.println("c ="+  c);
                    float f = curImage[c][r];
                    sb.append(f);
                    sb.append("\n");

                }

            }
        }
        IO.writeFileFromString(sb.toString(), imageFile);
    }
    void writeMultiColumnAsciiFile(){
       List <float[][]> allImages   =   this.imagePane.getAllImages();
       File dir                     =   DirectoryManager.getExperimentDir();
       File imageFile               =   new File(dir,"asciiImage");
       StringBuilder sb             =   new  StringBuilder  ();

       int row                      =   this.getImageDescriptor().getNumberOfRows();
       int col                      =   this.getImageDescriptor().getNumberOfColumns();
        for (float[][] curImage : allImages) {
            for (int r = 0; r < row; r++) {
                 for (int c = 0; c < col; c++) {
                    float f = curImage[c][r];
                    sb.append(f);
                    sb.append(" ");

                }
                  sb.append("\n");

            }
        }
        IO.writeFileFromString(sb.toString(), imageFile);
    }


    public static void startImageJ(){

		boolean noGUI   =   false;
		int mode        =   ImageJ.STANDALONE;


 		ImageJ ij       = IJ.getInstance();
		if (!noGUI && (ij==null || (ij!=null && !ij.isShowing()))) {
			ij          = new ImageJ(null, mode);
			ij.exitWhenQuitting(false);
		}

		if (noGUI) { System.exit(0);}

    }
    public ImageJ getImageJ(){
        ImageJ imageJ = IJ.getInstance();
        if (imageJ == null){
            setupImageJPlugIn();// write IO plugin if it doesn't exists already
            startImageJ();
        }
        else {
          //  startImageJ();
        }

        return IJ.getInstance();
    }
    void exportToImageJ(){
       
        ImageJ imageJ =getImageJ();
        WindowManager.closeAllWindows() ;
        imageJ.toFront();
      
       
        ImagePlus ip = new ImagePlus("",this.getImagePane().getFloatProcessor().duplicate() );
        ip.show();
    }
    void closeImageJ(){
        ImageJ imageJ =  IJ.getInstance();
        if( imageJ ==null) { Runtime.getRuntime().gc(); return; }
        
        WindowManager.closeAllWindows();

        Runtime.getRuntime().gc();
        imageJ .setVisible(false);

        Runtime.getRuntime().gc();
        

    }
    ImageJ showImageJ(){
        ImageJ ij = getImageJ();
        ij.setVisible(true);
        ij.toFront();

        for ( Frame frame :  WindowManager.getNonImageWindows()) {
                frame.toFront();
        }

        int [] idList = WindowManager.getIDList();
        if (idList != null){
             for (int i = 0; i < idList.length; i++) {
                 int j          = idList[i];
                 WindowManager.getImage(j).getWindow().toFront();
            }
        }
    
        return ij;
    }
    void exportHyperStackToImageJ(){
         
        ImageJ imageJ =  showImageJ();
      /*
          try {
            Thread.sleep(500);
            //     WindowManager.closeAllWindows() ;
        } catch (InterruptedException ex) {
           ex.printStackTrace();
        }
*/
        WindowManager.closeAllWindows() ;
   
  

         File file             = ( File)getImageJList ().getSelectedValue ();
         if (file == null) {return;}

         FileInfo fi            =   new FileInfo();
         ImageDescriptor  id    =   this.getImageDescriptor();
 
         fi.directory             =     file .getParentFile().getAbsolutePath();
         fi.fileName              =     file .getName();
         fi.width                 =     id.getNumberOfColumns();
         try{
            fi.height             =     id.getNumberOfRows();
            fi.nImages            =     id.getNumberOfSlices()*id.getNumberOfElements();
            fi.fileType           =     FileInfo.GRAY32_FLOAT;
            fi.whiteIsZero        =     false;
            fi.intelByteOrder     =     !id.isBigEndian();
            fi.offset             =     0;
            fi.longOffset         =     0;
            fi.gapBetweenImages   =     0;
            fi.unit               =     "mm";
            fi.pixelWidth         =     id.getScaling1() ;
            fi.pixelHeight        =     id.getScaling2() ;
            fi.pixelDepth         =     id.getScaling3() ;
            int channels          =     1;
            int slices            =     id.getNumberOfSlices();
            int frames            =     id.getNumberOfElements();

            fi.info                  = "Channels in ImageJ are set to 1\n" +
                                       "Slices in ImageJ correspond to " +
                                       "Slices in ImageViewer.\n"+
                                       "Frames in ImageJ correspond to.\n" +
                                       "Elements in ImageViewer.\n";


               FileOpener fo            = new FileOpener(fi);
               ImagePlus imp            = fo.open(false);
               imp.setDimensions(channels, slices, frames);
               imp.setFileInfo(fi);
               imp.setOpenAsHyperStack(true);
               imp.show();

		} catch (Exception e) {
            e.printStackTrace();
		 } finally {
		}
    }
    boolean   writeImageJPlugin (File dst){
         InputStream is             =   getClass().getResourceAsStream(IMAGEJ_PLUGIN_JAR);
         boolean isCopied           =   IO.copy(is, dst);
         return  isCopied;
    }
    File getPluginFile(){
        String filename     =   "plugins/Input-Output/"+IMAGEJ_IO_JAR_NAME;
        File dir            =    DirectoryManager.getBayesDir();
        File jarFile        =   new File(dir, filename);
        return  jarFile;
    }
    void setupImageJPlugIn(){
        File  pluginfile = getPluginFile();
        if ( pluginfile.exists() ){return;}

        else {
            writeImageJPlugin( pluginfile);
        }
    }
     


    public void flipVerticallyAllImages(){

        List< float[][] > allImages  =  getImagePane().getAllImages();
        for (float[][] img : allImages) {
            flipVerticallyImage(img);
        }
        updateImage();
    }
    public void flipVerticallyImage(float [][] image){

        for (int i = 0; i < image.length; i++) {
            float [] tmp    =   image[i];
            float [] rev    =   new float[tmp.length];
            for (int j = 0; j < tmp.length; j++) {
                rev[j] = tmp[tmp.length  - 1-j];

            }
            image[i]   =    rev;

        }
    }
    public void flipHorizontallyAllImages(){

        List< float[][] > allImages  =  getImagePane().getAllImages();
        for (float[][] img : allImages) {
            flipHoriizontallyImage(img);
        }
        updateImage();
    }
    public void flipHoriizontallyImage(float [][] image){
        int iMax            =   image.length/2;

        for (int i = 0; i < iMax; i++) {

            float [] tmp    =  image[i].clone();
            int upIndx      =  image.length - 1 -i;
            image[i]        =  image[ upIndx];
            image[ upIndx]  =  tmp;


        }
    }

    public void updateImage() {
        if ( getSelectedFile() == null ) {
            updateNoImage();
            return;
        }
        else{
            // show all widgets and update their state
            setActive();

            // draw image
            drawCurrentImage(false);

        }
        
      
    }
    public void updateImageList(){
         updateImageList(-1);
    }
    public void updateImageList(int imageToShowIndex){

           setIgnoreEvents(true);

           DefaultListModel oldList = (DefaultListModel) getImageJList ().getModel();

            // update list of available files and update GUI
            DefaultListModel newList = generateDefaultListModel();
            getImageJList ().setModel(newList);

            setIgnoreEvents(false);

            // if no image files are found   - reset and exit
            if ( newList.isEmpty()){   updateImage();  return; }
              

            // if already know which file to load
            int lastIndex           =    newList.getSize() -1;
            if ( imageToShowIndex   >= 0 &&  imageToShowIndex <=  lastIndex ){
                getImageJList ().setSelectedIndex( imageToShowIndex);
                return;
            }





            long lastModified       =   0;
            File recentFile         =   (File )newList.get(0);

            for (int curFile = 0; curFile < newList.getSize(); curFile ++) {
                File file       = (File )newList.get(curFile);

                if (file.lastModified() > lastModified){
                    lastModified    =   file.lastModified();
                    recentFile      =   file;
                }

                if (oldList.contains(file) == false){
                    loadImageFile(file);
                    getImageJList ().setSelectedValue(file, true);
                    return;
                }
            }

             getImageJList ().setSelectedValue(recentFile , true);
     


    }
    public void updateNoImage() {

            getImagePane().setImage(null);
            getImagePane().setRoi(null);
            getImagePane().repaint();
            getCalibrationBar().setVisible(false);
            getImageToolBar ().setVisible(false);
            tollBarPane.setVisible(false);
            PanelUtility.setVisible(    getImageControlPane()   , false);
            PanelUtility.setVisible(    getStatisticsPane()     , false);
            PanelUtility.setVisible(    getPixelInfoPane()      , false);


            resetSlidersPane();



    }
    public void setActive() {
            tollBarPane.setVisible(true);
            getCalibrationBar().setVisible(true);
            getImageToolBar ().setVisible(true);
            PanelUtility.setVisible(    getImageControlPane(), true);
            PanelUtility.setVisible(    getStatisticsPane() , true);
            PanelUtility.setVisible(    getPixelInfoPane()  , true);

    }
    public void drawCurrentImage(boolean keepScale){
            int curElement          = getElement ();
            int curSlice            = getSlice ();
            getImagePane(). drawScaledImage( curSlice, curElement, keepScale);

            // make sure image and calibration bar are in sync
            syncImageAndClibrationBar();
    }

    private void syncImageAndClibrationBar(){
        double min  =   getImagePane().getMinColorVal();
        double max  =   getImagePane().getMaxColorVal();
        getCalibrationBar().update(min, max);

    }

    public void imageRename(String oldname, String newname){
        try{
            File imgfile = DirectoryManager.getImageFileByName(oldname);
            File ifhfile = DirectoryManager.getIfhFileForImage(imgfile);
            File dir     =  imgfile.getParentFile();
       //  imgfile.r

        }
        catch (Exception e){
            e.printStackTrace();
        }
        finally{

        }


    }
    public Image getDisplayedImage(){
        return getImagePane().getImage();
    }


    public void showGUI(JFrame frame) {
        if (this.isShowing()) {
            return;
        }
        if (frame == null) {
            frame = new JFrame();
            frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
        }

        frame.setContentPane(this);

        frame.pack();
        frame.setVisible(true);
    }
    public void showGUI(JComponent pane) {
        if (pane == null) {
            return;
        }
        pane.removeAll();
        pane.add(this);
        pane.revalidate();
        pane.repaint();
    }
    private static void createAndShowGUI() {
        //Disable boldface controls.
        UIManager.put("swing.boldMetal", Boolean.FALSE);

        //Create and set up the window.
        JFrame frame = new JFrame("FID Binary Viewer");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

        //Create and set up the content pane.
        ImageViewer newContentPane = ImageViewer.getInstance();
        // FidViewer newContentPane = new FidViewer ( new File("test.fid"));
        newContentPane.setOpaque(true); //content panes must be opaque

        frame.setContentPane(newContentPane);

        //Display the window.
        frame.pack();
        frame.setVisible(true);
        
    }
    public static void main(String[] args) {

        //Schedule a job for the event-dispatching thread:
        //creating and showing this application's GUI.
        /*
       javax.swing.SwingUtilities.invokeLater(new Runnable() {

            public void run() {
                createAndShowGUI();
            }
        });
         */
    //startImageJ();

      boolean noGUI   =   false;
		int mode        =   ImageJ.STANDALONE;


 		ImageJ ij       = IJ.getInstance();
		if (!noGUI && (ij==null || (ij!=null && !ij.isShowing()))) {
			ij          = new ImageJ(null, mode);
			ij.exitWhenQuitting(false);
		}
        System.out.println( ImageJ.VERSION);
		if (noGUI) { System.exit(0);}


    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel ImageAndCalibrationBar;
    private javax.swing.JPanel PixelInfoPane;
    private javax.swing.JButton autoColorButton;
    private image.JCalibrationBar calibrationBar;
    private javax.swing.JLabel elementMaxLabel;
    private javax.swing.JFormattedTextField element_ftxt;
    private javax.swing.JLabel element_label;
    private javax.swing.JSlider element_slider;
    private javax.swing.JButton exportToImageJButton;
    private javax.swing.JButton extractPixelButton;
    private javax.swing.JButton flipHorizontallyButton;
    private javax.swing.JButton flipVerticalyButton;
    private javax.swing.JRadioButton freehandPointRB;
    private javax.swing.JButton getStatsButton;
    private javax.swing.JButton getThresholdStatsButton;
    private javax.swing.JList imageJList;
    private javax.swing.JPanel imageListPane;
    private image.ImagePane imagePane;
    private javax.swing.JButton imageResetButton;
    private javax.swing.JScrollPane imageScrollPanel;
    private javax.swing.JToolBar imageToolbar;
    private javax.swing.JPanel imahgeAndSettingsScrollPamel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JToolBar.Separator jSeparator1;
    private javax.swing.JToolBar.Separator jSeparator2;
    private javax.swing.JToolBar.Separator jSeparator3;
    private javax.swing.JToolBar.Separator jSeparator4;
    private javax.swing.JToolBar.Separator jSeparator5;
    private javax.swing.JToolBar.Separator jSeparator6;
    private javax.swing.JToolBar.Separator jSeparator7;
    private javax.swing.JToolBar.Separator jSeparator8;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JPanel paddedCalibrationBar;
    private javax.swing.JFormattedTextField roiMaxTF;
    private javax.swing.JFormattedTextField roiMeanTF;
    private javax.swing.JFormattedTextField roiMinTF;
    private javax.swing.JFormattedTextField roiPixelsTF;
    private javax.swing.JRadioButton roiPointRB;
    private javax.swing.JRadioButton roiRectnagularRB;
    private javax.swing.JFormattedTextField roiRmsTF;
    private javax.swing.JFormattedTextField roiSdevTF;
    private javax.swing.ButtonGroup roiType;
    private javax.swing.JButton saveStatsButton;
    private javax.swing.JButton settingsButton;
    private javax.swing.JPanel setup_pane;
    private javax.swing.JLabel sliceMaxLabel;
    private javax.swing.JFormattedTextField slice_ftxt;
    private javax.swing.JLabel slice_label;
    private javax.swing.JSlider slice_slider;
    private javax.swing.JPanel statPane;
    private javax.swing.JFormattedTextField textField1;
    private javax.swing.JFormattedTextField textField2;
    private javax.swing.JFormattedTextField textField3;
    private javax.swing.JPanel tollBarPane;
    private javax.swing.JPanel toolpane;
    private javax.swing.JButton zoomButton;
    private org.jdesktop.beansbinding.BindingGroup bindingGroup;
    // End of variables declaration//GEN-END:variables
    public javax.swing.JPanel       getImageControlPane() {
        return setup_pane;
    }
    public javax.swing.JPanel       getStatisticsPane() {
        return statPane;
    }
    public javax.swing.JPanel       getPixelInfoPane() {
        return PixelInfoPane;
    }
    public javax.swing.JList        getImageJList () {
        return imageJList;
    }
    public javax.swing.JSlider      getSliceSlider () {
        return slice_slider;
    }
    public javax.swing.JSlider      getElementSlider () {
        return element_slider;
    }
  
    public image.JCalibrationBar    getCalibrationBar () {
        return calibrationBar;
    }
    public ImagePane                getImagePane(){
          return imagePane ;
    } 
    public JToolBar                  getImageToolBar () {
        return imageToolbar;
    }
    public javax.swing.JLabel       getElementMaxLabel () {
        return elementMaxLabel;
    }
    public javax.swing.JLabel       getSliceMaxLabel () {
        return sliceMaxLabel;
    }

    public javax.swing.JFormattedTextField getTextField1 () {
        return textField1;
    }
    public javax.swing.JFormattedTextField getTextField2 () {
        return textField2;
    }
    public javax.swing.JFormattedTextField getTextField3 () {
        return textField3;
    }
    public javax.swing.JFormattedTextField getStatMeanTextField () {
        return roiMeanTF;
    }
    public javax.swing.JFormattedTextField getStatMaxTextField () {
        return roiMaxTF;
    }
    public javax.swing.JFormattedTextField getStatMinTextField () {
        return roiMinTF;
    }
    public javax.swing.JFormattedTextField getStatSdevTextField () {
        return roiSdevTF;
    }
    public javax.swing.JFormattedTextField getGuiStatRmsTextField () {
        return roiRmsTF;
    }
    public javax.swing.JFormattedTextField getGuiStatNumPixelsTextField () {
        return roiPixelsTF;
    }



    public void setGUIStatMean(String text){
            getStatMeanTextField().setText(text);
    }
    public void setGUIStatMin(String text){
            getStatMinTextField().setText(text);
    }
    public void setGUIStatMax(String text){
            getStatMaxTextField().setText(text);
    }
    public void setGUIStatSdev(String text){
            getStatSdevTextField().setText(text);
    }
    public void setGUIStatRms(String text){
           getGuiStatRmsTextField () .setText(text);
    }
    public void setGUIStatPixels(String text){
             getGuiStatNumPixelsTextField ().setText(text);
    }


    public String getGUIStatMean(){
           return getStatMeanTextField().getText();
    }
    public String getGUIStatMin(){
             return getStatMinTextField().getText();
    }
    public String getGUIStatMax(){
             return getStatMaxTextField().getText();
    }
    public String getGUIStatSdev(){
             return getStatSdevTextField().getText();
    }
    public String getGUIStatRms(){
            return getStatSdevTextField().getText();
    }
    public String getGUIStatPixels(){
            return  getGuiStatNumPixelsTextField () .getText();
    }


    public void setMultipleImageSelectionMode(){
        getImageJList ().setSelectionMode(javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
    }
    public void setSingleImageSelectionMode(){
        getImageJList ().setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);

    }
    public boolean isSingleSelectionMode(){
        int curSelectionMode = getImageJList ().getSelectionMode();
        if (curSelectionMode  == ListSelectionModel.SINGLE_SELECTION){
            return true;
        }
        return false;
    }


   // static  private ImageJ imageJ               =   null;
    private boolean ignoreEvents                =   false;
    private boolean isDeserilized               =   false;
    NumberFormat    intFormat                   =   NumberFormat.getIntegerInstance();


    public int getToolID () {
        return this.getImagePane().getTOOL_ID();
    }
    public int getElement () {
        return  getElementSlider().getValue() - 1;
   }
    public int getSlice () {
        return  getSliceSlider().getValue() - 1;
   }
    public int getCurrentElement() {
        return  getElementSlider().getValue();
   }
    public int getCurrentSlice() {
        return  getSliceSlider().getValue() ;
   }
    public int getNSlices(){
       ImageDescriptor id =  getImageDescriptor();
       if (id == null) {return 1;}
       else {return id.getNumberOfSlices();}
    }
    public int getNElements(){
       ImageDescriptor id = getImageDescriptor();
       if (id == null) {return 1;}
       else {return id.getNumberOfElements();}
    }
    public int getNReadOut(){
       return getImageDescriptor().getNumberOfRows();
    }
    public int getNPhaseEncode(){
       return getImageDescriptor().getNumberOfColumns();
    }


    public  boolean isImageSelected(){
        return !getImageJList().isSelectionEmpty();
    }
    public  File     getSelectedFile(){
        File  file       =   ( File)getImageJList().getSelectedValue();
        return file;
    }
    public  File     getSelectedIFHFile(){
        File imageFile  =  getSelectedFile();
        File file       =  DirectoryManager.replaceImgByIFH(imageFile);
        return file;
    }
    public  List <File>  getSelectedFiles(){
        List <File> files           = new ArrayList <File>() ;
        try{
            Object [] values        =   getImageJList().getSelectedValues();
            for (Object object : values) {
                if (object instanceof File){
                    files.add((File)object);
                }
            }
        }
        catch (Exception e){e.printStackTrace();}
        finally{
            return files ;
        }
        
    }
    public  List <File>  getSelectedImgAndIfhFiles(){
        List <File> files               =   new ArrayList <File>() ;
        try{
            List <File> imgFiles        =   getSelectedFiles();
            for (File imgFile : imgFiles) {
                 File ifhFile      =  DirectoryManager.replaceImgByIFH(imgFile);
                 files.add(imgFile);
                 files.add(ifhFile);
            }

        }
        catch (Exception e){e.printStackTrace();}
        finally{
            return files ;
        }

    }
 

    public  DefaultListModel  generateDefaultListModel(){
        DefaultListModel dm     =   new DefaultListModel();
        File [] files           =   DirectoryManager.getImageFileList();
        if (files == null) {return dm;}

        Arrays.sort(files);
        for (int i = 0; i < files.length; i++) {
            dm.add(i, files[i]);
            
        }

        return dm;
    }
  

    public static boolean isValidImageFile (File file) {
        if(file == null || file.exists() == false) {return false;}
        File ifhFile =  DirectoryManager.replaceImgByIFH (file);
        if(ifhFile == null || ifhFile.exists() == false) {return false;}
        return true;
    }
    public boolean isIsDeserilized () {
        return isDeserilized;
    }
    public boolean isIgnoreEvents () {
        return ignoreEvents;
    }

    public ImageDescriptor getImageDescriptor(){
       return getImagePane().getImageDescriptor();
    }


    public void  setSlice (int i) {
       slice_ftxt.setText(""+i);
       
   }
    public void  setElement (int i) {
       element_ftxt.setText(""+i);
       
   }

    public void setIgnoreEvents ( boolean ignoreEvents ) {
        this.ignoreEvents = ignoreEvents;
    }
    public void setIsDeserilized ( boolean isDeserilized ) {
        this.isDeserilized = isDeserilized;
    }
    public void setImageDescriptor(ImageDescriptor id){
       getImagePane().setImageDescriptor(id);
    }
 
    public void setTollID ( int id ) {
        getImagePane().setTOOL_ID(id);
    }

    public File getRoiDir() {
        return roiDir;
    }
    public void setRoiDir(File roiDir) {
        this.roiDir = roiDir;
    }
    public Roi getRoi(){
       return  this.getImagePane().getRoi();
    }


  


   class SliceSelectionFieldVerifier extends InputVerifier {
         public boolean verify(JComponent input) {
 	       JTextField tf = (JTextField) input;
               double val       = Double.parseDouble(tf.getText());
               double n         = getNSlices();
               double max       = n;
               double min       = 0;
               
               if (val  > max ) {tf.setText(String.valueOf(max));}
               if (val  < min ) {tf.setText(String.valueOf(min));}
               return true;
         }
     }
   class ElementSelectionFieldVerifier extends InputVerifier {
         public boolean verify(JComponent input) {
 	       JTextField tf = (JTextField) input;
               double val       = Double.parseDouble(tf.getText());
               double n         = getNElements();
               double max       = n;
               double min       = 0;
               
               if (val  > max ) {tf.setText(String.valueOf(max));}
               if (val  < min ) {tf.setText(String.valueOf(min));}
               return true;
         }
     } 
   class CustomCellRenderer extends JCheckBox implements ListCellRenderer {
     public String getToolTip(){

        StringBuilder sb = new StringBuilder();
        ImageDescriptor id =  getImageDescriptor();
        if (id == null) {return sb.toString();}

        sb.append("<html>");
        String info     = id.toString();
        Scanner scanner = new Scanner(info);
        while (scanner.hasNextLine()){
            
             sb.append(scanner .nextLine());
             sb.append("<br>");
        }

        sb.append("</html>");

        return sb.toString();

    }
     public CustomCellRenderer() {
        setOpaque(true);
        
    
  }
     public Component getListCellRendererComponent(JList list, Object value,
            int index, boolean isSelected, boolean cellHasFocus) {
            File entry = (File) value;
            setText(entry.getName());
            setFont( imageListfont);
            
            boolean currentlyDisplayed = false;
            if (list.getSelectedValue() == value){
                currentlyDisplayed = true;
            }
           /*
           boolean currentlyDisplayed = false;
           Component comp = (Component)getImageJList().gets
           if(comp == this){
               currentlyDisplayed = true;
            }
            * 
            */
            setBackground(Color.BLACK);
            if (currentlyDisplayed){
                    setForeground(Color.RED);
                    setSelected(true);
            }
            else if (isSelected) {
                    setForeground(Color.RED);
                    setSelected(false);
             
            } else {
                    setForeground(Color.WHITE);
                    setSelected(false);
            }


            return this;
      }
 }
   class PixelExtractor {
        int numberSlices                        =   getNSlices();
        int numberElements                      =   getNElements();
        int curSlice                            =   getCurrentSlice() - 1;
        List <File> imagefiles                  =   getSelectedFiles();
        int fileabscissaColumns                 =   0;
        int modelAbscissaColumns                =   0;
        int modeldataColumns                    =   0;
        int numberOfdatasets                    =   0;
        String delimiter                        =   "\t";
        List <String>  abscissa                 =   new ArrayList<String>();
        Map <Integer, List<float[]>>   datasets =   new HashMap<Integer, List<float[]>>();
        Float lowthreshold                      =    null;
        Float highthreshold                     =    null;

        public PixelExtractor (){
            numberSlices                        =   ImageViewer.this.getNSlices();
            numberElements                      =   ImageViewer.this.getNElements();
            curSlice                            =   ImageViewer.this.getCurrentSlice() - 1;
            imagefiles                          =   ImageViewer.this.getSelectedFiles();

            Model model                         =   PackageManager.getCurrentApplication();
            if (model != null){
                modelAbscissaColumns            =   model.getNumberOfAbscissa();
                modeldataColumns                =   model.getNumberOfDataColumns();
                numberOfdatasets                =   imagefiles.size()/ modeldataColumns;
            }

        }



       public void      extractPixel(){
           boolean canProceed                   =     canExtractPixels();
           if (canProceed  == false){return;}

           if (ImageViewerPreferences.isThresholdImagePixelExtraction() == true){
              JPixelThreshold statDialog = JPixelThreshold.showDialog( );
              if (statDialog.isProceed()){
                lowthreshold            =   statDialog.getLowerThreshold();
                highthreshold           =   statDialog.getUpperThreshold();

              }
              else{
                return;

              }
          }

         
           // extract and store pixel information for all images
           readAllImagePixels();

           for (int curDataSet = 0; curDataSet < numberOfdatasets; curDataSet++) {
                String content   =   writeFileContent(curDataSet);
                writeFile  (content);
           }

            AllViewers.showAsciiViewer();
       }

       public String    writeFileContent(int dataset ){
          StringBuilder sb                      =    new StringBuilder();


           if (modelAbscissaColumns > 1){
             for (int curElem = 0; curElem < numberElements ; curElem++) {


               // if(Float.compare(val, Float.NaN) == 0){continue;}
                
                // write curElem
                sb.append(curElem);
                sb.append(delimiter);

                // write data columsns (potentially multi column)
                for (int curDataCol = 0; curDataCol <modeldataColumns; curDataCol++) {
                        double val = datasets.get( dataset  ).get(curDataCol ) [curElem];
                        sb.append(val);
                        sb.append(delimiter);
                 }
                
                sb.append(abscissa .get(curElem));
                sb.append(delimiter);

                sb.append(BayesManager.EOL);
            }
        }
        else if (modelAbscissaColumns == 1){

           for (int curElem = 0; curElem < numberElements ; curElem++) {


               // if(Float.compare(val, Float.NaN) == 0){continue;}
                sb.append(abscissa .get(curElem));
                sb.append(delimiter);

                // write data columsns (potentially multi column)
                for (int curDataCol = 0; curDataCol <modeldataColumns; curDataCol++) {
                        float val = datasets.get( dataset  ).get(curDataCol ) [curElem];
                        sb.append(val);
                        sb.append(delimiter);
                 }



                sb.append(BayesManager.EOL);
            }



        }




          return   sb.toString();
       }
       public void      writeFile(String content){
            int numOfCol                =   IO.getNumberOfColumns(content);
            int numOfRows               =   numberElements;
            String src                  =   "Roi pixels from loaded image.";
            String srsDesc              =   "";

        

            AsciiIO.writeAsciiData( content,src , srsDesc,numOfCol, numOfRows);
       
       }
       public boolean   canExtractPixels(){
        String message              =   null;
        int numberofimages          =   imagefiles.size();


        // check argument
        if (imagefiles.isEmpty()) {

             message                   =   "No image files are selected. Exiting...";
             DisplayText.popupMessage( message);
             return false;

        }

        if (numberofimages % modeldataColumns  != 0){
             message                   =    String.format(
                                             "Number of selected images (%s) must be"
                                            + "an integer multiple of number of data columns\n"
                                            + "required by current model(%s). Exiting...",
                                             numberofimages,
                                             modeldataColumns
                                            );
             DisplayText.popupErrorMessage( message);
             numberOfdatasets  =   0;
             return false;

        }

        // check roi
        Roi roi                     =   getImagePane().getRoi();
        if (roi == null) {
             message                   =   "No Region of Interest is specified. Exiting...";
             DisplayText.popupErrorMessage( message);
             return false;
        }

       

        // check image dimensions
        boolean samedimension       =   checkImageDimensions (  );
        if ( samedimension  == false){
            message                   =   "Selected images have different dimensions. Exiting...";
            DisplayText.popupErrorMessage( message);
            return false;
        }

        // If abscissa file exists....
        File abscissaFile           =   DirectoryManager.getAbscissaFile();
        if ( abscissaFile == null || abscissaFile.exists() == false){
            message                   =   "Abscissa file doesn't exist.";
            message                   +=   "\n";
            message                   +=   "Do you want to simulate abscissa?";
            boolean proceeed          = DisplayText.popupDialog( message);
            if (proceeed){
                 simulateAbscissa();
            }
            else{
                 return false;
            }
        }
        else { 
            //If abscissa  doesnt file exists....
            // check validity of abscissa file content
            readAbscissaValues();
            if (abscissa.isEmpty()){
                message                   =   "Error encountered while parsing absscissa file.";
                message                   +=   "\n";
                message                   +=   "Do you want to simulate abscissa?";
                boolean proceeed          =     DisplayText.popupDialog( message);
                if (proceeed){
                     simulateAbscissa();
                }
                else{
                     return false;
                }

            }
        }
        
        // check compatability with the model
        if ( modelAbscissaColumns !=  fileabscissaColumns ){
            DisplayText.popupMessage(   "Number of abscissa columns"+ "("+   modelAbscissaColumns+")\n"
                                      + "for the current model is not\n"
                                      + "equal to number of columns"+"("+ fileabscissaColumns+")\n"
                                      + "in the abscissa file\n"
                                      + "Exiting....");
            return false;
        }


        int numElements             =   getNElements();
        if ( numElements != abscissa.size()){
            message     =   "Number of elements "+ "( "+ numElements+" )\n";
            message     +=  "is different from\n";
            message     +=  "number of rows\n";
            message     +=  "in the abscissa file"+ " ( "+abscissa.size()+" )\n" ;
            message     +=  "Exiting..." ;
            DisplayText.popupErrorMessage(message);
            return false;
        }



       return true;



    }
       public void      simulateAbscissa(){
          int simAbscissaLength                     =    getNElements();
          abscissa.clear();
          String val                                =  "";
          String tab                                =  "\t";
          for (int i = 0; i < simAbscissaLength ; i++) {
              val                                   =   ""; 
              for (int j = 0; j <   modelAbscissaColumns; j++) {
                  val           +=  i + tab;
              }
              abscissa.add(val.trim());
          }
          fileabscissaColumns           =   modelAbscissaColumns; 
       }
       public boolean   checkImageDimensions(){
        boolean samedims            =   true;
        ImageDescriptor    id       =   null;
        try{
            for (File imagefile : imagefiles) {
                File ifh                =   DirectoryManager.getIfhFileForImage( imagefile );
                ImageDescriptor curid   =   ImageIO.loadFromDisk(ifh  );

                if (id == null){
                    id                = curid;
                    continue;
                }
                else{
                   boolean same =   curid.compareDimensions(id);
                   if (same == true){
                       continue;
                   }
                   else{
                      samedims  =  false;
                       break;
                   }

                }

            }


        }
        catch(Exception e){e.printStackTrace();}
        finally{
            return samedims;
        }
    }
       private void     readAbscissaValues(){
            abscissa.clear();

            try{
                File abscissaFile       =   DirectoryManager.getAbscissaFile();
                abscissa                =   IO.ASCII2String(abscissaFile);
                fileabscissaColumns     =   IO.getNumberOfColumns(abscissaFile) ;
            }
            catch (Exception e){
                abscissa.clear();
                fileabscissaColumns     =   0;
                e.printStackTrace();}
            finally{

            }

    }
       public void      readAllImagePixels(){
           for (int curDataset = 0; curDataset < this.numberOfdatasets; curDataset++) {
               List datalist                =    new ArrayList<float []>();
               datasets.put(curDataset ,datalist    );

               for (int curDataCol = 0; curDataCol <  modeldataColumns; curDataCol++) {
                    float [] pixels      =  new float [numberElements ];
                    datalist .add(pixels);
               }
           }



        if (imagefiles.size()   > 1){
            int datasetcount                     =   0;
            int curImageInDataset                =   0;
            for (int curImg = 0; curImg < imagefiles.size(); curImg++) {
               
                File imagefile = imagefiles.get(curImg);
                readImagePixels(imagefile, datasetcount, curImageInDataset);

                if ((curImageInDataset + 1) == modeldataColumns ){
                    datasetcount += 1;     // record in counter
                    curImageInDataset = 0; // reset counter
                }
                else{
                     curImageInDataset +=1;
                }

            }
        }
        else{
             readImagePixels(ImageViewer.this.getImagePane().getAllImages(), 0, 0);
        }


     }
       public void      readImagePixels(File imageFile, int datasetcount, int curImageInDataset ){

            try{
                File descriptorFile          =       DirectoryManager.getIfhFileForImage(imageFile);
                ImageDescriptor id           =       ImageIO.loadFromDisk( descriptorFile);
                ImageIO  imageInfo           =       ImageIO.readImage(imageFile, id);
                List <float[][]> image      =       imageInfo.getImgArray();

                 readImagePixels (image, datasetcount,  curImageInDataset);

            }
            catch (Exception e){
                e.printStackTrace();}
            finally{

            }

    }
       public void      readImagePixels( List <float[][]> images  ,int datasetcount, int curImageInDataset){

            try{

                for (int curElement = 0; curElement < numberElements ; curElement++) {
                     int index              =  curSlice + curElement*numberSlices;
                     float[][] image        =   images.get(index );
                     float val             =   (float)getImagePane(). getRoiStatsForImage(image, lowthreshold, highthreshold).getMean();

                     datasets.get(datasetcount).get(curImageInDataset)[curElement] = val;
                }

            }
            catch (Exception e){
                e.printStackTrace();}
            finally{

            }

    }
   }
   class PixelHistogrammer {
        int modelAbscissaColumns                =   0;
        int modeldataColumns                    =   0;
        Float lowthreshold                      =    null;
        Float highthreshold                     =    null;

        public  PixelHistogrammer (){

            Model model                         =   PackageManager.getCurrentApplication();
            if (model != null){
                modelAbscissaColumns            =   model.getNumberOfAbscissa();
                modeldataColumns                =   model.getNumberOfDataColumns();
            }

        }


       public void      loadPixels(){
           boolean canProceed                   =     isValidConditions();
           if (canProceed  == false){return;}

           if (ImageViewerPreferences.isThresholdImagePixelExtraction()== true){
              JPixelThreshold statDialog = JPixelThreshold.showDialog( );
              if (statDialog.isProceed()){
                lowthreshold            =   statDialog.getLowerThreshold();
                highthreshold           =   statDialog.getUpperThreshold();

              }
              else{
                return;

              }
          }


           // extract and store pixel information for all images
           float [] pixels        =   getPixelsForHistogram();
           StringBuilder sb       =   getPixelsForHistogramAsText(pixels);
           writeFile (sb.toString(), pixels.length);


            AllViewers.showAsciiViewer();
       }
       public void      writeFile(String content, int npoints){
            int numOfCol                =   2;
            int numOfRows               =    npoints;
            String src                  =   "Roi pixels from loaded image.";
            String srsDesc              =   "";


            if(getRoi() == null){
                srsDesc                 += SOURCE_TYPE.HISTOGRAM_PIXEL.getInfo()+".";
                srsDesc                 += " Pixels from entrie image. ";
                srsDesc                 +=" Image slice = "+  getCurrentSlice()+"," ;
                srsDesc                 +=" image element = "+  getCurrentElement() +"." ;
            }

           else if(getRoi().getType() == Roi.POINT) {
                    srsDesc             += SOURCE_TYPE.HISTOGRAM_PIXEL.getInfo()+".";
                    srsDesc             +=" at "+ getImagePane().getRoiPixelsInfo();
                    srsDesc             +=" Image slice = "+  getCurrentSlice()+"," ;
                    srsDesc             +=" image element = "+  getCurrentElement() +"." ;
            }
            else{
                srsDesc = SOURCE_TYPE.HISTOGRAM_PIXEL.getInfo()+".";
                srsDesc             +=" Image slice = "+  getCurrentSlice()+"," ;
                srsDesc             +=" image element = "+  getCurrentElement() +"." ;
            }

            AsciiIO.writeAsciiData( content,src , srsDesc,numOfCol, numOfRows);

       }
       public boolean   isValidConditions(){
        String message              =   null;

        // check argument
        if ( isImageSelected() == false) {

             message                   =   "No image files are selected. Exiting...";
             DisplayText.popupErrorMessage( message);
             return false;

        }


        // check compatability with the model
        if (  modelAbscissaColumns != 1 ){
            message =   String.format(
                      "Loaded model requires %d abscissa columns.\n+"
                    + "The pixel plotting routine is only valid |n"
                    + "for models that require a single abscissa column.\n"
                    + "Exiting...",  modelAbscissaColumns );
            DisplayText.popupMessage(  message);
                                 
            return false;
        }

         if (  modeldataColumns != 1 ){
            message =   String.format(
                      "Loaded model requires %d data columns.\n+"
                    + "The pixel plotting routine is only valid |n"
                    + "for models that require a single data column.\n"
                    + "Exiting...",  modeldataColumns );
            DisplayText.popupMessage(  message);

            return false;
        }


       return true;



    }
   }

   class PixelExtractorNew{
        int numberSlices                        =   getNSlices();
        int numberElements                      =   getNElements();
        int curSlice                            =   getCurrentSlice() - 1;
        List <File> imagefiles                  =   getSelectedFiles();
        int fileabscissaColumns                 =   0;
        int modelAbscissaColumns                =   0;
        int modeldataColumns                    =   0;
        int numberOfdatasets                    =   0;
        int numberOfPixels                      =   0;
        boolean averagePixles                   =   true;
        boolean isROI                           =   false;
        String delimiter                        =   "\t";
        List <String>  abscissa                 =   new ArrayList<String>();
        Map <Integer, Map<Integer, List<float[]>>>   datasets 
                =   new HashMap<Integer, Map<Integer,List<float[]>>>();
        Float lowthreshold                      =    null;
        Float highthreshold                     =    null;

        public PixelExtractorNew (){
            numberSlices                        =   ImageViewer.this.getNSlices();
            numberElements                      =   ImageViewer.this.getNElements();
            curSlice                            =   ImageViewer.this.getCurrentSlice() - 1;
            imagefiles                          =   ImageViewer.this.getSelectedFiles();
            isROI                               =   getImagePane().isRoiApplied();
            
            Model model                         =   PackageManager.getCurrentApplication();
            if (model != null){
                modelAbscissaColumns            =   model.getNumberOfAbscissa();
                modeldataColumns                =   model.getNumberOfDataColumns();
                numberOfdatasets                =   imagefiles.size()/ modeldataColumns;
            }

        }



       public void      extractPixel(){
           boolean canProceed                   =     canExtractPixels();
           if (canProceed  == false){return;}

           if (ImageViewerPreferences.isThresholdImagePixelExtraction() == true){
              JPixelThreshold statDialog = JPixelThreshold.showDialog( );
              if (statDialog.isProceed()){
                lowthreshold            =   statDialog.getLowerThreshold();
                highthreshold           =   statDialog.getUpperThreshold();

              }
              else{
                return;

              }
          }

         
           // extract and store pixel information for all images
           readAllImagePixels();

           for (int curDataSet = 0; curDataSet < numberOfdatasets; curDataSet++) {
                String content   =   writeFileContent(curDataSet);
                writeFile  (content);
           }

            AllViewers.showAsciiViewer();
       }

       public String    writeFileContent(int dataset ){
          StringBuilder sb                      =    new StringBuilder();


           if (modelAbscissaColumns > 1){
             for (int curElem = 0; curElem < numberElements ; curElem++) {


               // if(Float.compare(val, Float.NaN) == 0){continue;}
                
                // write curElem
                sb.append(curElem);
                sb.append(delimiter);
                
                if (this.averagePixles){
                    // write data columsns (potentially multi column)
                    for (int curDataCol = 0; curDataCol <modeldataColumns; curDataCol++) {
                            double val = datasets.get( dataset).get(0).get(curDataCol ) [curElem];
                            sb.append(val);
                            sb.append(delimiter);
                     }
                
                }
                else {
                    // need to implement
                }
                
                sb.append(abscissa .get(curElem));
                sb.append(delimiter);

                sb.append(BayesManager.EOL);
            }
        }
        else if (modelAbscissaColumns == 1){

           for (int curElem = 0; curElem < numberElements ; curElem++) {


               // if(Float.compare(val, Float.NaN) == 0){continue;}
                sb.append(abscissa .get(curElem));
                sb.append(delimiter);
                
                
                 if (this.averagePixles){
                    // write data columsns (potentially multi column)
                    for (int curDataCol = 0; curDataCol <modeldataColumns; curDataCol++) {
                            float val = datasets.get( dataset ).get(0).get(curDataCol ) [curElem];
                            sb.append(val);
                            sb.append(delimiter);
                     }
                 }


                sb.append(BayesManager.EOL);
            }



        }




          return   sb.toString();
       }
       public void      writeFile(String content){
            int numOfCol                =   IO.getNumberOfColumns(content);
            int numOfRows               =   numberElements;
            String src                  =   "Roi pixels from loaded image.";
            String srsDesc              =   "";

        

            AsciiIO.writeAsciiData( content,src , srsDesc,numOfCol, numOfRows);
       
       }
       public boolean   canExtractPixels(){
        String message              =   null;
        int numberofimages          =   imagefiles.size();


        // check argument
        if (imagefiles.isEmpty()) {

             message                   =   "No image files are selected. Exiting...";
             DisplayText.popupMessage( message);
             return false;

        }

        if (numberofimages % modeldataColumns  != 0){
             message                   =    String.format(
                                             "Number of selected images (%s) must be"
                                            + "an integer multiple of number of data columns\n"
                                            + "required by current model(%s). Exiting...",
                                             numberofimages,
                                             modeldataColumns
                                            );
             DisplayText.popupErrorMessage( message);
             numberOfdatasets  =   0;
             return false;

        }

        // check roi
        Roi roi                     =   getImagePane().getRoi();
        if (roi == null) {
             message                   =   "No Region of Interest is specified. Exiting...";
             DisplayText.popupErrorMessage( message);
             return false;
        }

       

        // check image dimensions
        boolean samedimension       =   checkImageDimensions (  );
        if ( samedimension  == false){
            message                   =   "Selected images have different dimensions. Exiting...";
            DisplayText.popupErrorMessage( message);
            return false;
        }

        // If abscissa file exists....
        File abscissaFile           =   DirectoryManager.getAbscissaFile();
        if ( abscissaFile == null || abscissaFile.exists() == false){
            message                   =   "Abscissa file doesn't exist.";
            message                   +=   "\n";
            message                   +=   "Do you want to simulate abscissa?";
            boolean proceeed          = DisplayText.popupDialog( message);
            if (proceeed){
                 simulateAbscissa();
            }
            else{
                 return false;
            }
        }
        else { 
            //If abscissa  doesnt file exists....
            // check validity of abscissa file content
            readAbscissaValues();
            if (abscissa.isEmpty()){
                message                   =   "Error encountered while parsing absscissa file.";
                message                   +=   "\n";
                message                   +=   "Do you want to simulate abscissa?";
                boolean proceeed          =     DisplayText.popupDialog( message);
                if (proceeed){
                     simulateAbscissa();
                }
                else{
                     return false;
                }

            }
        }
        
        // check compatability with the model
        if ( modelAbscissaColumns !=  fileabscissaColumns ){
            DisplayText.popupMessage(   "Number of abscissa columns"+ "("+   modelAbscissaColumns+")\n"
                                      + "for the current model is not\n"
                                      + "equal to number of columns"+"("+ fileabscissaColumns+")\n"
                                      + "in the abscissa file\n"
                                      + "Exiting....");
            return false;
        }


        int numElements             =   getNElements();
        if ( numElements != abscissa.size()){
            message     =   "Number of elements "+ "( "+ numElements+" )\n";
            message     +=  "is different from\n";
            message     +=  "number of rows\n";
            message     +=  "in the abscissa file"+ " ( "+abscissa.size()+" )\n" ;
            message     +=  "Exiting..." ;
            DisplayText.popupErrorMessage(message);
            return false;
        }



       return true;



    }
       public void      simulateAbscissa(){
          int simAbscissaLength                     =    getNElements();
          abscissa.clear();
          String val                                =  "";
          String tab                                =  "\t";
          for (int i = 0; i < simAbscissaLength ; i++) {
              val                                   =   ""; 
              for (int j = 0; j <   modelAbscissaColumns; j++) {
                  val           +=  i + tab;
              }
              abscissa.add(val.trim());
          }
          fileabscissaColumns           =   modelAbscissaColumns; 
       }
       public boolean   checkImageDimensions(){
        boolean samedims            =   true;
        ImageDescriptor    id       =   null;
        try{
            for (File imagefile : imagefiles) {
                File ifh                =   DirectoryManager.getIfhFileForImage( imagefile );
                ImageDescriptor curid   =   ImageIO.loadFromDisk(ifh  );

                if (id == null){
                    id                = curid;
                    continue;
                }
                else{
                   boolean same =   curid.compareDimensions(id);
                   if (same == true){
                       continue;
                   }
                   else{
                      samedims  =  false;
                       break;
                   }

                }

            }


        }
        catch(Exception e){e.printStackTrace();}
        finally{
            return samedims;
        }
    }
       private void     readAbscissaValues(){
            abscissa.clear();

            try{
                File abscissaFile       =   DirectoryManager.getAbscissaFile();
                abscissa                =   IO.ASCII2String(abscissaFile);
                fileabscissaColumns     =   IO.getNumberOfColumns(abscissaFile) ;
            }
            catch (Exception e){
                abscissa.clear();
                fileabscissaColumns     =   0;
                e.printStackTrace();}
            finally{

            }

    }
       public void      readAllImagePixels(){
           for (int curDataset = 0; curDataset < this.numberOfdatasets; curDataset++) {
               List datalist                =    new ArrayList<float []>();
               if (this.averagePixles){
                    datasets.get(0).put(curDataset ,datalist    );
                 

                   for (int curDataCol = 0; curDataCol <  modeldataColumns; curDataCol++) {
                        float [] pixels      =  new float [numberElements ];
                        datalist .add(pixels);
                   }
               }
               else{
               
               }
              
           }



        if (imagefiles.size()   > 1){
            int datasetcount                     =   0;
            int curImageInDataset                =   0;
            for (int curImg = 0; curImg < imagefiles.size(); curImg++) {
               
                File imagefile = imagefiles.get(curImg);
                readImagePixels(imagefile, datasetcount, curImageInDataset);

                if ((curImageInDataset + 1) == modeldataColumns ){
                    datasetcount += 1;     // record in counter
                    curImageInDataset = 0; // reset counter
                }
                else{
                     curImageInDataset +=1;
                }

            }
        }
        else{
             readImagePixels(ImageViewer.this.getImagePane().getAllImages(), 0, 0);
        }


     }
       public void      readImagePixels(File imageFile, int datasetcount, int curImageInDataset ){

            try{
                File descriptorFile          =       DirectoryManager.getIfhFileForImage(imageFile);
                ImageDescriptor id           =       ImageIO.loadFromDisk( descriptorFile);
                ImageIO  imageInfo           =       ImageIO.readImage(imageFile, id);
                List <float[][]> image      =       imageInfo.getImgArray();

                 readImagePixels (image, datasetcount,  curImageInDataset);

            }
            catch (Exception e){
                e.printStackTrace();}
            finally{

            }

    }
       public void      readImagePixels( List <float[][]> images  ,int datasetcount, int curImageInDataset){

            try{

                if (averagePixles){
                    for (int curElement = 0; curElement < numberElements ; curElement++) {
                        int index              =  curSlice + curElement*numberSlices;
                        float[][] image        =   images.get(index );
                        float val             =   (float)getImagePane(). getRoiStatsForImage(image, lowthreshold, highthreshold).getMean();

                        datasets.get(datasetcount).get(0).get(curImageInDataset)[curElement] = val;
                    }
                }
                else {
                
                    // extract individual pixels
                }

            }
            catch (Exception e){
                e.printStackTrace();}
            finally{

            }

    }
   }
}
  
