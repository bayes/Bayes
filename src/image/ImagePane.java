/*
 * ImagePane.java
 *
 * Created on October 21, 2008, 3:19 PM
 */

package image;

import bayes.ApplicationPreferences;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.Dimension;
import java.awt.Cursor;
import java.awt.Point;
import java.awt.Component;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.geom.Rectangle2D;
import java.awt.Polygon;
import java.util.*;
import javax.swing.*;
import ij.process.*;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
/**
 *
 * @author  apple
 */
public class ImagePane extends javax.swing.JPanel implements ImageConstants{
    public static final  Font LABEL_FONT        =   new java.awt.Font("Helvetica", 1, 18);
    private Image image                         =   null;
    private float aspectRatio                   =   1f;
    private FloatProcessor ip                   =   null;
    private  Roi roi                            =   null;
    private Rectangle clip                      =   new Rectangle(0, 0, 0, 0);
    public  boolean showAllROIs                 =   true;
    private  int TOOL_ID                        =   Roi.RECTANGLE;
    private float horizontalScale               =   1.0f;
    private  float verticalScale                =   1.0f;
    protected List< float[][] > allImages       =   new ArrayList< float[][] > ();
    private  ImageDescriptor imageDescriptor    =   null;
    private boolean zoomed                      =   false;
    private double  maxColorVal                 =   1;
    private double  minColorVal                 =   0;

    // this is o be used by ImageViewer to set up x,y, values fields
    private int pixelX                          =   -1;
    private int pixelY                          =   -1;
    private float pixelValue                    =   Float.NaN;

    private List<Point> roiPoints               =   new ArrayList<Point>();

    

    /** Creates new form ImagePane */
    public ImagePane() {
        initComponents();
      
    }

    public void reset(){
        setImage(null);
        setFloatProcessor ( new FloatProcessor(100, 100) );
        setAspectRatio(1);
        setHorizontalScale(1.0f);
        setVerticalScale(1.0f);
        setZoomed(false);
        setRoi(null);
        showAllROIs     =   true;
        setClip(new Rectangle(0, 0, 0, 0));
        setImageDescriptor(null);
        allImages.clear();
    }



    @Override
    public  void paintComponent(Graphics g){
         super.paintComponent(g);
    }

    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        xAxis = new XAxis();
        yAxis = new YAxis();
        canvas = new Canvas();

        FormListener formListener = new FormListener();

        setBackground(new java.awt.Color(0, 0, 15));
        setBorder(javax.swing.BorderFactory.createEtchedBorder(new java.awt.Color(0, 0, 153), null));
        setLayout(new java.awt.BorderLayout());

        xAxis.setBackground(new java.awt.Color(0, 0, 0));
        xAxis.setName("xAxis"); // NOI18N

        org.jdesktop.layout.GroupLayout xAxisLayout = new org.jdesktop.layout.GroupLayout(xAxis);
        xAxis.setLayout(xAxisLayout);
        xAxisLayout.setHorizontalGroup(
            xAxisLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 545, Short.MAX_VALUE)
        );
        xAxisLayout.setVerticalGroup(
            xAxisLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 38, Short.MAX_VALUE)
        );

        add(xAxis, java.awt.BorderLayout.SOUTH);

        yAxis.setBackground(new java.awt.Color(0, 0, 0));
        yAxis.setName("yAxis"); // NOI18N
        yAxis.setPreferredSize(new Dimension ( YAXIS_WIDTH, 100));

        org.jdesktop.layout.GroupLayout yAxisLayout = new org.jdesktop.layout.GroupLayout(yAxis);
        yAxis.setLayout(yAxisLayout);
        yAxisLayout.setHorizontalGroup(
            yAxisLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 10, Short.MAX_VALUE)
        );
        yAxisLayout.setVerticalGroup(
            yAxisLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 445, Short.MAX_VALUE)
        );

        add(yAxis, java.awt.BorderLayout.WEST);

        canvas.setBackground(new java.awt.Color(0, 0, 0));
        canvas.setName("canvas"); // NOI18N
        //canvas.setPreferredSize(new Dimension (MAX_IMAGE_WIDTH , MAX_IMAGE_HEIGHT));
        canvas.addMouseListener(formListener);
        canvas.addMouseMotionListener(formListener);
        canvas.setLayout(new java.awt.BorderLayout());
        add(canvas, java.awt.BorderLayout.CENTER);
        canvas.setCursor(new Cursor (Cursor.CROSSHAIR_CURSOR));
    }

    // Code for dispatching events from components to event handlers.

    private class FormListener implements java.awt.event.MouseListener, java.awt.event.MouseMotionListener {
        FormListener() {}
        public void mouseClicked(java.awt.event.MouseEvent evt) {
        }

        public void mouseEntered(java.awt.event.MouseEvent evt) {
        }

        public void mouseExited(java.awt.event.MouseEvent evt) {
        }

        public void mousePressed(java.awt.event.MouseEvent evt) {
            if (evt.getSource() == canvas) {
                ImagePane.this.canvasMousePressed(evt);
            }
        }

        public void mouseReleased(java.awt.event.MouseEvent evt) {
            if (evt.getSource() == canvas) {
                ImagePane.this.canvasMouseReleased(evt);
            }
        }

        public void mouseDragged(java.awt.event.MouseEvent evt) {
            if (evt.getSource() == canvas) {
                ImagePane.this.canvasMouseDragged(evt);
            }
        }

        public void mouseMoved(java.awt.event.MouseEvent evt) {
            if (evt.getSource() == canvas) {
                ImagePane.this.canvasMouseMoved(evt);
            }
        }
    }// </editor-fold>//GEN-END:initComponents

private void canvasMouseMoved(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_canvasMouseMoved
        int x           =   evt.getX();
        int y           =   evt.getY();
        Point pnt       =   getScaledPoint( evt.getPoint());


        setPixelX( -1);
        setPixelY( -1 );
        setPixelValue(Float.NaN);
        
        if (getFloatProcessor() != null){
       
            Rectangle imageBounds =  getImageBounds();
            if (imageBounds.contains(x, y)){
                  float value     =     getFloatProcessor().getPixelValue( x, y) ;
                  this.setPixelX( pnt.x );
                  this.setPixelY( pnt.y );
                  this.setPixelValue( value);
                 
            }
        }
        if (getRoi() != null) {
             getRoi(). handleMouseMove(x,y);
        }
}//GEN-LAST:event_canvasMouseMoved
private void canvasMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_canvasMouseReleased
        // boolean re = true;
        // if(re)return;
       int x           =   evt.getX();
       int y           =   evt.getY();


       if (getRoi() != null) {
            Rectangle r = getRoi().getBounds();
            int type    = getRoi().getType();

         
            if ((r.width==0 || r.height==0)
            && getRoi().getState()==Roi.CONSTRUCTING
            && type!=Roi.POINT)
            {
              killRoiWithoutSaving();
              
            }
            else{
                getRoi().handleMouseUp(x, y);
            }
        }
}//GEN-LAST:event_canvasMouseReleased
private void canvasMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_canvasMousePressed

        if(SwingUtilities.isRightMouseButton (evt)  == true)  {
            if(this.getImage() == null){return;}
            JPopupMenu popup        = new ImageViewerPopupMenu();
            popup.show (evt.getComponent (), evt.getX (), evt.getY ());
         }
        else{

             int x           =   evt.getX();
             int y           =   evt.getY();

            if (getTOOL_ID() == Roi.POINT){
                setRoi(new PointRoi(x, y, getCanvas()));
                getRoi().handleMouseDown(x, y);
            }
            if (getRoi() == null &&  getTOOL_ID() == Roi.POLYGON){
                setRoi(new PolygonRoi(x, y, getCanvas()));
           }

            else if( getRoi() != null) {
                int handle          =    getRoi().isHandle(x, y);

                if (getRoi().getState()==Roi.CONSTRUCTING) {
                    // do nothing
                 }
                 else  if (handle >= 0) {
                    getRoi().mouseDownInHandle(handle);
                }
                else if (getRoi().contains(x,y)) {
                    getRoi().handleMouseDown(x, y);
                }
                else {
                      killRoiWithoutSaving();
                      getCanvas().repaint();
                 }
            }
        }



}//GEN-LAST:event_canvasMousePressed
private void canvasMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_canvasMouseDragged
        int x           =   evt.getX();
        int y           =   evt.getY();
        if (getFloatProcessor() == null){return;}
        
        else {

            int maxX        =   getFloatProcessor().getWidth();
            int maxY        =   getFloatProcessor().getHeight();

            if (x < maxX && y < maxY){
                 if (  getRoi() == null) {
                   if(getTOOL_ID() == Roi.RECTANGLE){
                            setRoi(new Roi(x, y, getCanvas()));
                    }
                    else if (this.getTOOL_ID() == Roi.POLYGON){
                            setRoi(new PolygonRoi(x, y, getCanvas()));
                    }
                 }

                    getRoi().setXMax(maxX - 1);
                    getRoi().setYMax(maxY - 1);
                    getRoi().handleMouseDrag(x,y);
            }
           
        }
}//GEN-LAST:event_canvasMouseDragged


     public void  drawScaledImage(int curSlice, int curElement, boolean preserveScale){
        float[][]  pixels           =       getPixels ( curSlice, curElement);
        FloatProcessor newFp        =       new FloatProcessor (pixels);
        setFloatProcessor (newFp);
        setImage(getScaledeImage(preserveScale));
        repaint();
     }
     

     public Image getScaledeImage(boolean preserveScale) {
        Image anImage           =   null;
        FloatProcessor fp       =   getFloatProcessor ();

        // if imaged was not scaled, calculate default scale
        if (isZoomed() == false){
            fp                  =       scaleImage(fp);

            setFloatProcessor(fp);

        }
        else {
            fp.setRoi(getClip());
            fp                      = ( FloatProcessor) getFloatProcessor ().crop();
            fp                      =  scaleCropedImage(fp);
            setFloatProcessor(fp);

       }


        if ( preserveScale){
                getFloatProcessor().setMinAndMax(getMinColorVal(), getMaxColorVal());
        }
         else if(ImageViewerPreferences.isAutoContrastNewImage() == false)
        {
                getFloatProcessor().setMinAndMax(getMinColorVal(), getMaxColorVal());
        }
        else   {
                setMinColorVal(getFloatProcessor().getMin());
                setMaxColorVal(getFloatProcessor().getMax());
        }


        anImage           =  getFloatProcessor().createImage();
        return anImage ;
    }
     public Statistics getImageStatistics(float [][] image) {
        Statistics stats    =   new Statistics();
        double max          =   Double.MIN_VALUE;
        double min          =   Double.MAX_VALUE;
        double mean         =   0;
        double sd           =   0;
        double sum          =   0;
        double sqrDiff      =   0;
        int totalPoints     =   1;
        
        for (int i = 0; i < image.length; i++) {
             float [] subImage  = image[i];
             for (int j = 0; j < subImage.length; j++) {
                  float f = subImage[j];
                  
                  if (f > max) {max = f;}
                  if (f < min) {min = f;}
                  sum   =    sum +f;
                  totalPoints++;
                 
             }
         }
        
        mean    =   sum/totalPoints;
        
        for (int i = 0; i < image.length; i++) {
             float [] subImage  = image[i];
             for (int j = 0; j < subImage.length; j++) {
                 float f = subImage[j];
                  sqrDiff = sqrDiff + (f - mean)*(f - mean);
             }
         }
        
        
        sd              =   Math.sqrt(sqrDiff/totalPoints);
        
        
       
        stats.setMean(mean);
        stats.setMax(max);
        stats.setMin(min);
        stats.setSdev(sd);
        return  stats ;
    }
     public double[] computeImageStackStatistics() {
        double max      =   Double.MIN_VALUE;
        double min      =   Double.MAX_VALUE;

         for (float[][] curImage : allImages) {
            Statistics stats = getImageStatistics(curImage);

             if (stats.getMax() > max)  {max = stats.getMax() ;}
             if (stats.getMin() < min)  {min = stats.getMin() ;}
         }

        return new double [ ]{min, max} ;
    }
     public double[] computeImageStatistics(int curSlice, int curElement){
        float[][]  pixels           =       getPixels ( curSlice, curElement);
        double max      =   0;
        double min      =   1;

            Statistics stats = getImageStatistics(pixels );

            max = stats.getMax() ;
            min = stats.getMin() ;

        return new double [ ]{min, max} ;
    }

     public FloatProcessor  scaleImage(FloatProcessor fp) {
        
        float curImageHeight        =   (float)fp.getHeight()  ;
        float curImageWidth         =   (float)fp.getWidth()  ;
        float canvasHeight          =   (float)MAX_IMAGE_HEIGHT;
        float canvasWidth           =   (float)MAX_IMAGE_WIDTH;
        
        float scaleVertical         =   (float)canvasHeight / curImageHeight;
        float scaleHorizontal       =   (float)canvasWidth / curImageWidth;

        if (aspectRatio > 1) {
            scaleVertical           =  scaleVertical /aspectRatio;
        }
        else {
            scaleHorizontal           =    scaleHorizontal  * aspectRatio;
        }
        
        
        int newWidth                  =   (int)(curImageWidth  * scaleHorizontal );   
        int newHeight                 =   (int)(curImageHeight* scaleVertical  );   
        
        setHorizontalScale(scaleHorizontal);
        setVerticalScale(scaleVertical);
        
        fp.setInterpolate(false);
        FloatProcessor newFp   =  (FloatProcessor) fp.resize(newWidth, newHeight);

        return newFp ;
    }
     public FloatProcessor  scaleCropedImage(FloatProcessor fp) {
        float curImageHeight        =   (float)fp.getHeight()  ;
        float curImageWidth         =   (float)fp.getWidth()  ;
        float canvasHeight          =   (float)MAX_IMAGE_HEIGHT;
        float canvasWidth           =   (float)MAX_IMAGE_WIDTH;
        
        ImageDescriptor id          =   this.getImageDescriptor();
        double  widthMMperPix    =       id.getScaling1();
        double  heightMMperPix   =       id.getScaling2();


        double aRatio                 = ImageDescriptor.computeImageAspectRatio(
                widthMMperPix, heightMMperPix, curImageWidth, curImageHeight );
         
        double scaleVertical           =   canvasHeight / curImageHeight;
        double scaleHorizontal         =   canvasWidth / curImageWidth;
        
        if (aRatio > 1) {
            scaleVertical           =  scaleVertical /aRatio ;
        }
        else {
            scaleHorizontal           =    scaleHorizontal  *aRatio ;
        }
        
        int newWidth                  =   (int)(curImageWidth  * scaleHorizontal );
        int newHeight                 =   (int)(curImageHeight * scaleVertical );
        
        setHorizontalScale((float)scaleHorizontal);
        setVerticalScale((float)scaleVertical );

        fp.setInterpolate(false);
        FloatProcessor newFp   =  (FloatProcessor) fp.resize(newWidth, newHeight);
        
        return newFp ;
    }

    //
     
     public void zoomImageFromRectangleRoi() {
        if (getRoi() == null) { return;}
        if (getTOOL_ID() != Roi.RECTANGLE ){return;}
         
        Rectangle r = getRoi().getBounds();
        killRoiWithoutSaving();
        updateScaledRoiBounds(r);
        setZoomed(true); 
        
    }
     public void unZoomImage() {
        setClip(new Rectangle(0, 0, 0, 0)) ;
        killRoiWithoutSaving();
        setZoomed(false);
    }
     public void killRoiWithoutSaving() {
        if (getRoi()!=null) { setRoi(null); repaint();}
    }
 
  
    
    public Rectangle    updateScaledRoiBounds( Rectangle roiBounds ){
        
        float     hScl       = getHorizontalScale();
        float     vScl       = getVerticalScale();
     
        double offsetH      = roiBounds.getX()/ hScl;
        double offsetV      = roiBounds.getY() /vScl;
        double unscaledEndX = roiBounds.getX() + roiBounds.getWidth();
        double unscaledEndY = roiBounds.getY() + roiBounds.getHeight();
        
        int    scaledStartX = (int) Math.floor( offsetH ); 
        int    scaledStartY = (int) Math.floor(offsetV);
        int    scaledEndX   = getClip().x+ (int) Math.ceil(unscaledEndX/ hScl);
        int    scaledEndY   = getClip().y +(int) Math.ceil(unscaledEndY/ vScl);
        
        int    x            = getClip().x        + scaledStartX;
        int    y            = getClip().y        + scaledStartY;
        int    width        = scaledEndX - x;  
        int    height       = scaledEndY - y;  
        
        getClip().setBounds(x, y, width, height);
        return getClip();
     
     }
    public Point        getScaledPoint( Point pixel){
        return new Point( getScaledX(pixel.x),getScaledY(pixel.y));
     
     }
    public int          getScaledX( int pixelx){
        float  scale     = getHorizontalScale();
        int    x         = getClip().x        + (int) Math.floor( pixelx/scale );
        return  x  ;
    }
    public int          getScaledY (int pixely){
        float  scale     = getVerticalScale();
        int    y         = getClip().y        + (int) Math.floor( pixely/scale);
        return  y  ;
    }
 

    // calculates rectangular shape for given 2-dimensional array
    public Rectangle getImageBounds(float image [][]){
         Rectangle bounds   =     new Rectangle();
         int width          =     image.length;
         int height         =     image[0].length; 
         bounds.setBounds(0, 0,  width, height );
         
         return bounds;
    }

    // return original image pixels as one-dimensional array of doubles
    public float []      getImagePixelsAs1DArray(float [][] image){
        // reset
        int x                              =    image.length ;
        int y                              =    image[0].length;
        float []  pixels                   =    new float[x*y];

        int count                          =    0;
        for (int curX = 0; curX < x; curX++) {
           for (int curY = 0; curY < y ; curY++) {
                 pixels  [count] = image[curX][curY];
                 count++;

           }
        }

        return  pixels;
    }    

    // retun original image roi pixels
    public float []      getImagePixelsContainedInRoi(float [][] image){
        Rectangle bounds                        =   getImageBounds(image );
        List <Point>    roiPixels               =    getRoiPixels(bounds  );
        int npoints                             =    roiPixels    .size();
        float [] imageRoiPixels                 =    new float [npoints ];
        for (int i = 0; i < imageRoiPixels.length; i++) {
           Point p                              =       roiPixels     .get(i);
           imageRoiPixels[i]                    =       image [p.x][p.y];

        }

        setRoiPoints ( roiPixels    );
        
        return imageRoiPixels;
    }

    // retun original image roi pixels
    public List <Point>     getRoiPixels( Rectangle imageBounds){
         List <Point>  roipixels          =  new ArrayList<Point>();

        if (TOOL_ID == Roi.POINT){
               int x                       =    roi.x;
               int y                       =    roi.y;
               x                           =    getScaledX(x) ;
               y                           =    getScaledY(y)  ;
               roipixels  .add(new Point(x, y));

        }
        else if(TOOL_ID == Roi.POLYGON){
               int[] xp                    =    roi.getPolygon().xpoints.clone();
               int[] yp                    =    roi.getPolygon().ypoints.clone();
               int   np                    =    roi.getPolygon().npoints;

               for (int p = 0; p < np; p++) {
                xp[p]                      =    getScaledX(xp[p] );
                yp[p]                      =    getScaledY(yp[p] );

            }
               Polygon poly                 =   new   Polygon(xp, yp, np);
               Rectangle bounds             =   poly.getBounds();
               int bx                       =   (int)bounds.getX();
               int by                       =   (int)bounds.getY();
               int bwidth                   =   (int)bounds.getWidth();
               int bheight                  =   (int)bounds.getHeight();

                for (int x = bx; x < bx + bwidth; x++) {
                    for (int y = by; y < by + bheight; y++) {
                    if (poly .contains(x, y)  && imageBounds.contains( x, y)){
                        roipixels  .add(new Point(x, y));
                    }
                }
            }

        }
        else if(TOOL_ID == Roi.RECTANGLE){
               int x                       =    roi.x;
               int y                       =    roi.y;
               int w                       =    roi.width;
               int h                       =    roi.height;
               int x2                      =    x + w;
               int y2                      =    y + h;

               x                           =    getScaledX(x) ;
               y                           =    getScaledY(y)  ;
               x2                          =    getScaledX(x2) ;
               y2                          =    getScaledY(y2)  ;


               for (int curX = x; curX <= x2; curX++) {
                   for (int curY = y; curY <= y2 ; curY++) {
                     if (imageBounds.contains( curX, curY)){
                         roipixels  .add(new Point(curX, curY));
                     }

                   }
                }



        }


        return  roipixels;
    }
    
    


    // calculate statistics on one dimensional float array
    public  Statistics calculatStatistics(float [] pixels) {
        Statistics stats            =   new Statistics();
        double max                  =  -Double.MAX_VALUE;
        double min                  =   Double.MAX_VALUE;
        double mean                 =   0;
        double sd                   =   0;
        double sum                  =   0;
        double sqrDiff              =   0;
        double sqrSum               =   0;
        double meanSqrSum           =   0;
        double rms                  =   0;
        int pixelcounts             =   pixels.length;
        for (int i = 0; i <pixelcounts ; i++) {
                 float f    =   pixels[i];
                 max            =   Math.max(max, f);
                 min            =   Math.min(min, f);
                 sum            =   sum +f;
                 sqrSum         =   sqrSum  + f*f;
        }


        mean                    =   sum/pixelcounts;
        meanSqrSum              =   sqrSum/pixelcounts;
        for (Float pixelval : pixels) {
             sqrDiff = sqrDiff + (pixelval - mean)*(pixelval - mean);
         }

        sd              =   Math.sqrt(sqrDiff/pixelcounts);
        rms             =   Math.sqrt(meanSqrSum );


        stats.setMean(mean);
        stats.setMin(min);
        stats.setMax(max);
        stats.setSdev(sd);
        stats.setRootMeanSqare(rms);
        stats.setNumelements(pixelcounts);

        return  stats ;
    }


   // get thresholded pixels values
    public  float []  thresholdPixels(float [] pixels, Float lowerthreshold, Float upperthreshold) {
        float [] temp               =   new float [pixels.length];
        int count                   =   0;

        boolean isLowerThreshold    =  false;
        boolean isUpperThreshold    =  false;

        if (lowerthreshold != null && lowerthreshold.isNaN() == false){
            isLowerThreshold        =   true;
        }
        if (upperthreshold != null  && upperthreshold.isNaN()  == false){
           isUpperThreshold         =   true;
        }

        if(isLowerThreshold == true && isUpperThreshold == true)
        {
            for (int i = 0; i < pixels.length; i++) {
                 float f    =   pixels[i];
                 if (f < lowerthreshold){continue;}
                 if (f > upperthreshold ){continue;}
                 temp [count]  =       f;
                 count         +=      1;
            }
        }
        else if(isUpperThreshold == true )
        {
            for (int i = 0; i < pixels.length; i++) {
                 float f    =   pixels[i];
                 if (f > upperthreshold ){continue;}
                 temp [count]  =       f;
                 count         +=      1;
            }
        }
        else if(isLowerThreshold == true )
        {
            for (int i = 0; i < pixels.length; i++) {
                 float f    =   pixels[i];
                 if (f < lowerthreshold ){continue;}
                 temp [count]  =       f;
                 count         +=      1;
            }
        }

        else{
           return pixels;
        }

        float []thresholdedPixels =   new float[count];
        System.arraycopy(temp , 0,thresholdedPixels, 0, count);
        return  thresholdedPixels ;
    }


    // calculate statistics for image with index i
    public Statistics getRoiStatsForImageAt(int i, Float lowerthreshold, Float highthreshold){
        List <float [][]> img     =         getAllImages();

        if (img.isEmpty() || img.size() <=i){ return new Statistics();}
        else {  return  getRoiStatsForImage (img.get(i), lowerthreshold,  highthreshold); }
      
    }
      // calculate statistics for image with index i
    public Statistics getRoiStatsForImage(float [][] img, Float lowerthreshold, Float highthreshold ){
            float []   pixels           =    getImagePixelsContainedInRoi(img);
            pixels                      =    thresholdPixels(pixels, lowerthreshold, highthreshold);
            Statistics  stats           =    calculatStatistics(pixels);
            return stats;
    }

    public  float [] getRoiPixelsForImageAt(int i){
       if (getAllImages().isEmpty() || getAllImages().size() <=i){
            return null;
       }
     
        float [][] img          =   getAllImages().get(i);
        float []   pixels;
        if (getRoi() == null){
             pixels             =    getImagePixelsAs1DArray(img);
        }
        else{
             pixels             =    getImagePixelsContainedInRoi(img);
        }

        return pixels;
    }
    
    
    // convenience methof to check whether ROi is applied
    public boolean isRoiApplied(){
     boolean out    =  false;
     try{
         out          = this.getRoi() != null;
     }
     finally{
             return out;
     }
    
    }
    
    // calculate statistics for image with at given slice and element number
    public Statistics getRoiStatsForImageAt(int slice, int element,Float lowerthreshold, Float upperthreshold ){
            float [][] img          =    getPixels(slice,element);
            float []   pixels;
            if (isRoiApplied() == false){
                 pixels       =    getImagePixelsAs1DArray(img);
            }
            else{
                 pixels       =    getImagePixelsContainedInRoi(img);
            }
            float [] thresholdedPix     =  thresholdPixels(pixels, lowerthreshold, upperthreshold);
            Statistics stats            =    calculatStatistics(thresholdedPix  );
            return stats;
    }

    // get roi  pixels in image original coordinates as String
    public String getRoiPixelsInfo(){
        StringBuilder sb             = new StringBuilder();
        List<Point> points          = this.getRoiPoints();
        for (Point point : points) {
            sb.append("x = "+ point.x + "  y = "+  point.y);
        }

        return sb.toString();
    }

    public void         createNewRoi(int sx, int sy, Component ic) {
        killRoiWithoutSaving();
        switch (getTOOL_ID()) {
            case Roi.RECTANGLE  : setRoi(new Roi(sx, sy, ic));break;
                
            case Roi.OVAL       :  /* roi = new OvalRoi(sx, sy, ic) */;break;
                
            case Roi.POLYGON    : break;
            case Roi.POLYLINE   : break;
            case Roi.ANGLE      : /*roi = new PolygonRoi(sx, sy, ic)*/;break;
            case Roi.FREEROI    : break;
            case Roi.FREELINE   : /*roi = new FreehandRoi(sx, sy, ic)*/;break;
            case Roi.LINE       : /*roi = new Line(sx, sy, ic)*/; break;
            case Roi.POINT      : /*roi = new PointRoi(sx, sy, this)*/; break;
               
        }
    }
    public boolean      isRectangleRoi(){
        return (getTOOL_ID() == Roi.RECTANGLE);
  }
 

   
     
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel canvas;
    private javax.swing.JPanel xAxis;
    private javax.swing.JPanel yAxis;
    // End of variables declaration//GEN-END:variables
    // get Gui Elements
    public javax.swing.JPanel getCanvas () {
        return canvas;
    }
    public javax.swing.JPanel getXAxis () {
        return xAxis;
    }
    public javax.swing.JPanel getYAxis () {
        return yAxis;
    }


    public FloatProcessor   getFloatProcessor () {
        return ip;
    }
    public void             setFloatProcessor ( FloatProcessor ip ) {
        this.ip =ip;
    }
    public int              getImageProcessorWidth (){return  getFloatProcessor().getWidth();}
    public int              getImageProcessorHeight (){return getFloatProcessor().getHeight();}


    public Image            getImage () {
        return image;
    }
    public void             setImage ( Image image ) {
        this.image = image;
    }


    public  int             getCanvasHeight() {
        return  getCanvas().getHeight();
    }
    public  int             getCanvasWidth() {
        return  getCanvas().getWidth();
    }
    
    public Rectangle        getImageBounds(){
        int width           =    getFloatProcessor() .getWidth();
        int height          =    getFloatProcessor() .getHeight();
        int x               =    0;
        int y               =    0;
        Rectangle bounds    =  new Rectangle (x, y, width, height);
        return bounds;
    }

    public float            getAspectRatio () {
        return aspectRatio;
    }
    public void             setAspectRatio ( float aspectRatio ) {

        this.aspectRatio = aspectRatio;
    }

    public   float[][]      getPixels ( int curSlice,  int curElement ) {
         // curSlice and curElement are starting from 0
         int slc            =   getImageDescriptor().getNumberOfSlices();
         int index          =   curSlice + curElement*slc;
        
         float[][] pixels   =   getAllImages().get(index);
         return  pixels;
   }

    public   List<float[][]> getAllImages () {
        return allImages;
    }
    public   void           setAllImages ( List<float[][]> aAllImages ) {
        allImages = aAllImages;
    }

    public   ImageDescriptor getImageDescriptor () {
        return imageDescriptor;
    }
    public   void           setImageDescriptor ( ImageDescriptor aImageDescriptor ) {
        imageDescriptor = aImageDescriptor;
    }

    public   float          getHorizontalScale () {
        return horizontalScale;
    }
    public   void           setHorizontalScale ( float magnification ) {
        horizontalScale = magnification;
    }

    public   float          getVerticalScale () {
        return verticalScale;
    }
    public   void           setVerticalScale ( float aVerticalScale ) {
        verticalScale = aVerticalScale;
    }

    public boolean          isZoomed () {
        return zoomed;
    }
    public void             setZoomed ( boolean zoomed ) {
        this.zoomed = zoomed;
    }
  
    public float            getPixelValue () {
        return pixelValue;
    }
    public void             setPixelValue ( float pixelValue ) {
        this.pixelValue = pixelValue;
    }
    
    public int              getPixelX () {
        return pixelX;
    }
    public void             setPixelX ( int pixelX ) {
        this.pixelX = pixelX;
    }
    
    public int              getPixelY () {
        return pixelY;
    }
    public void             setPixelY ( int pixelY ) {
        this.pixelY = pixelY;
    }


    public double           getMaxColorVal () {
        return maxColorVal;
    }
    public void             setMaxColorVal ( double maxColorVal ) {
        this.maxColorVal = maxColorVal;
    }

    public double           getMinColorVal () {
        return minColorVal;
    }
    public void             setMinColorVal ( double minColorVal ) {
        this.minColorVal = minColorVal;
    }

    public int              getTOOL_ID () {
        return TOOL_ID;
    }
    public void             setTOOL_ID ( int TOOL_ID ) {
        this.TOOL_ID = TOOL_ID;
    }

    public Roi              getRoi () {
        return roi;
    }
    public void             setRoi ( Roi roi ) {
        this.roi = roi;
    }
    
    public Rectangle        getClip () {
        return clip;
    }
    public void             setClip ( Rectangle clip ) {
        this.clip = clip;
    }

    public List<Point>      getRoiPoints () {
        return roiPoints;
    }
    public void             setRoiPoints ( List<Point> roiPoints ) {
        this.roiPoints = roiPoints;
    }
  

   
    public static void main (String args []){

    FloatProcessor fp = new FloatProcessor(64, 64);
      System.out.println(fp.getInterpolate());
     // fp.setInterpolate(false);
       FloatProcessor newFp
               =   (FloatProcessor)fp.resize(128, 128);
       System.out.println(newFp.getInterpolate());

  }

    
    
    class Canvas extends JPanel{
         int longTickLength     =   6;
         int shortTickLength    =   3;
         int majorTick          =   32;
         int minorTick          =   16;
         int tickLabelStep      =   64;
         String tickLabelFormat =   "%1.2f";
       
         @Override
         public  void paintComponent(Graphics g){
          super.paintComponent(g);
          g.drawImage(ImagePane.this.getImage(),0,0, null);
          if (getRoi() != null && image!= null) { getRoi().draw(g);}
        
          if (getImage() != null) {
             g.setColor(Color.WHITE);
            drawAxisAndTicks(g);
            getYAxis ().repaint();
            getXAxis ().repaint();
          }
        
         }
         void drawAxisAndTicks(Graphics g){
            int height          =    getImage().getHeight(this);//getHeight();
            int width           =   getImage().getWidth(this);//getWidth();
            int lastX           =   width -1;
            int lastY           =   height - 1;
            int pos             =   0;
            
            
            g.drawLine(0, 0,  0,height);          // right vertical axis
            g.drawLine(lastX, 0,  lastX,height);  // left  vertical axis
            g.drawLine(0, 0,  width,0);           // top horizontal axis
            g.drawLine(0, lastY,  width,lastY);   // bottom horozontal axis
         
          // draw y- axis ticks
            while(pos < height){
                int length;
                if (pos%majorTick == 0){
                    length = longTickLength;
                }
                else {
                    length = shortTickLength;
                }
                g.drawLine(0, pos, length, pos);
                g.drawLine(lastX, pos, lastX -length, pos);
                pos +=minorTick;
           }
           
           pos    = 0;
           // draw  x-axis ticks
           while(pos < width){
                int length;
                if (pos%majorTick == 0){
                    length = longTickLength;
                }
                else {
                    length = shortTickLength;
                }
                g.drawLine( pos, lastY,pos, lastY -length);
                g.drawLine( pos, 0, pos, length);
                pos +=minorTick;
           }
         }
         void drawTickLabels(Graphics g){
            int height          =   getHeight();
            int width           =   getWidth();
            int lastX           =   width -1;
            int lastY           =   height - 1;
            double mmPixX       =   ImagePane.this.getImageDescriptor().getScaling1(); // mm per pixel
            double mmPixY       =   ImagePane.this.getImageDescriptor().getScaling2(); 
            int pos             =   0;
            FontMetrics fm      =   g.getFontMetrics();
            
            
            // draw y- axis ticks
            pos    = tickLabelStep;
             while(pos < height){
                 int length          = longTickLength + 5;
                 int    pix         =  getScaledY(pos);
                 double yInMM       =  pix*mmPixY;
                 String str         =  String.format(tickLabelFormat, yInMM) ;
                 g.drawString(str,length,pos + (int)(fm.getAscent()/2));
                 pos +=  tickLabelStep ;
          }
          
          // draw x- axis ticks
           pos    = tickLabelStep;
           while(pos < height){
                 int length         = longTickLength + 5;
                 int    pix         =  getScaledX(pos);
                 double xInMM       =  pix*mmPixX;
                 String str         =  String.format(tickLabelFormat, xInMM) ;
                 Rectangle2D bounds   =  fm.getStringBounds(str, g); 
                 g.drawString(str, pos - (int)(bounds.getWidth()/2),lastX -length);
                 pos +=  tickLabelStep ;
          }
         }
    }
    class YAxis extends JPanel{
         int longTickLength     =   4;
         int shortTickLength    =   6;
         int majorTick          =   32;
         int minorTick          =   16;
         int tickLabelStep      =   64;
         int offset             =    0 ;
         String tickLabelFormat =   "%1.2f";
        
         @Override
         public  void paintComponent(Graphics g){
           super.paintComponent(g);
           
             if (getImage() != null) {
             g.setColor(Color.WHITE);
             drawTickLabels(g);
          }
         }
         void   drawTickLabels(Graphics g){
          


             Graphics2D g2 = (Graphics2D)g;
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                        RenderingHints.VALUE_ANTIALIAS_ON);


            int height          =   getHeight();
            int width           =   getWidth();
            int imgHeight       =   getImage().getHeight(this);
            double mmPixY       =   ImagePane.this.getImageDescriptor().getScaling2(); 
            int pos             =   0;
            FontMetrics fm      =   g2.getFontMetrics();
            int pixelSize       =  (int)Math.ceil( getVerticalScale ()); 
            while (tickLabelStep < pixelSize ){
                tickLabelStep*=2;
            }
            
            if (tickLabelStep >=height) {tickLabelStep = height;}
            // draw y- axis ticks
            pos                 =  offset;
          
            while(pos - offset< imgHeight ){
                 
                 int    pix         =  getScaledY(pos -offset );
                 double yInCM       =  pix*mmPixY/10;
                 String str         =  String.format(tickLabelFormat, yInCM) ;
                 Rectangle2D bounds =  fm.getStringBounds(str, g); 
                 int posX           =  width - (int)bounds.getWidth()- 5;
                 g2.drawString(str,posX,pos + (int)(fm.getAscent()/2)+3);
                 pos +=  tickLabelStep ;
          }


                // Create a rotation transformation for the font.
                AffineTransform fontAT = new AffineTransform();

                // get the current font
                Font theFont = g2.getFont();

                // Render a string using the derived font
                String label        =   ImagePane.this.getImageDescriptor().getyLabel();
                if (label == null){ label  = "y";}

                fm                              =   g2.getFontMetrics();
                Rectangle2D bounds              =   fm.getStringBounds(label, g2);
                

                // Derive a new font using a rotatation transform
                fontAT.rotate(-Math.PI/2);
                Font theDerivedFont     =   LABEL_FONT.deriveFont(fontAT);
                // set the derived font in the Graphics2D context
                g2.setFont(theDerivedFont);
                
                int xpos                        =   (int)(bounds.getHeight());
                int ypos                        =   (int)(imgHeight /2 + bounds.getWidth()/2);
                g2.drawString(label,xpos ,ypos);
                // put the original font back
                g2.setFont(theFont);

         }

     }
    class XAxis extends JPanel{
         int longTickLength     =   4;
         int shortTickLength    =   6;
         int majorTick          =   32;
         int minorTick          =   16;
         int tickLabelStep      =   64;
         int offset             =   YAXIS_WIDTH;
         String tickLabelFormat =   "%1.2f";
        
         @Override
         public  void paintComponent(Graphics g){
           super.paintComponent(g);
             if (getImage() != null) {
             g.setColor(Color.WHITE);
             drawTickLabels(g);
          }
         }  
         void drawTickLabels(Graphics g){
            Graphics2D g2 = (Graphics2D)g;
            g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
                        RenderingHints.VALUE_ANTIALIAS_ON);
            int height          =   XAXIS_HEIGHT;
            int width           =   getWidth();
            int imgWidth        =   getImage().getWidth(this);
            int lastY           =   height - 1;
            double mmPixX       =   ImagePane.this.getImageDescriptor().getScaling1(); // mm per pixel
            int pos             =   0;




            FontMetrics fm      =   g.getFontMetrics();
            int pixelSize       =  (int)Math.ceil( getHorizontalScale ()); 
            while (tickLabelStep < pixelSize ){
                tickLabelStep*=2;
            }
            
            if (tickLabelStep >=width) {tickLabelStep = width;}
            
           pos    = offset;
           while(pos - offset< imgWidth ){
                
                 int length         =  20;
                 int    pix         =  getScaledX(pos - offset);
                 double xInCM       =  pix*mmPixX/10;
                 String str         =  String.format(tickLabelFormat, xInCM) ;
                 Rectangle2D bounds =  fm.getStringBounds(str, g2);
                 g2.drawString(str, pos - (int)(bounds.getWidth()/2),lastY -length);
                 pos +=  tickLabelStep ;
          }


            
            String label                    =   ImagePane.this.getImageDescriptor().getxLabel();
            if (label == null){ label       =   "x";}
            g2.setFont(LABEL_FONT);
            fm                              =   g2.getFontMetrics();
            Rectangle2D bounds              =   fm.getStringBounds(label, g2);
            int xpos                        =   (int)(imgWidth/2 + offset -bounds.getWidth()/2);
            int ypos                        =   (int)(height -2);
            g2.drawString(label,xpos ,ypos );
         }
 
    }
}
